// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RdsPacket.proto

#ifndef PROTOBUF_RdsPacket_2eproto__INCLUDED
#define PROTOBUF_RdsPacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace RdsProtobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RdsPacket_2eproto();
void protobuf_AssignDesc_RdsPacket_2eproto();
void protobuf_ShutdownFile_RdsPacket_2eproto();

class Prm300;
class SmolenskRpu;
class ReceiverOptions;
class ChannelOptions;
class DeviceOptions;
class TimeFreqArea;
class Mode;
class System;
class System_SystemOptions;
class System_Device;
class System_Receiver;
class System_SeparateReceiver;
class Location;
class Location_LocationOptions;
class Location_FilterOptions;
class Detector;
class Detector_DetectorOptions;
class Analysis;
class Analysis_AnalysisOptions;
class DataStatus;
class LocationSpectrum;
class LocationXCov;
class DetectorSpectrum;
class AnalysisSpectrogram;
class ClientMessage;
class ClientMessage_GetMessage;
class ClientMessage_SetMessage;
class ServerMessage;
class ServerMessage_CurrentMessage;
class ServerMessage_DataMessage;
class ServerMessage_AnswerMessage;
class ServerMessage_AnswerMessage_Error;
class ServerMessage_AnswerMessage_Confirmation;
class Packet;

// ===================================================================

class Prm300 : public ::google::protobuf::MessageLite {
 public:
  Prm300();
  virtual ~Prm300();

  Prm300(const Prm300& from);

  inline Prm300& operator=(const Prm300& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Prm300& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Prm300* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Prm300* other);

  // implements Message ----------------------------------------------

  Prm300* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Prm300& from);
  void MergeFrom(const Prm300& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 freq = 1;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 1;
  inline ::google::protobuf::int32 freq() const;
  inline void set_freq(::google::protobuf::int32 value);

  // required int32 filter = 2;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 2;
  inline ::google::protobuf::int32 filter() const;
  inline void set_filter(::google::protobuf::int32 value);

  // required int32 attenuator1 = 3;
  inline bool has_attenuator1() const;
  inline void clear_attenuator1();
  static const int kAttenuator1FieldNumber = 3;
  inline ::google::protobuf::int32 attenuator1() const;
  inline void set_attenuator1(::google::protobuf::int32 value);

  // required int32 attenuator2 = 4;
  inline bool has_attenuator2() const;
  inline void clear_attenuator2();
  static const int kAttenuator2FieldNumber = 4;
  inline ::google::protobuf::int32 attenuator2() const;
  inline void set_attenuator2(::google::protobuf::int32 value);

  // required int32 chanNum = 5;
  inline bool has_channum() const;
  inline void clear_channum();
  static const int kChanNumFieldNumber = 5;
  inline ::google::protobuf::int32 channum() const;
  inline void set_channum(::google::protobuf::int32 value);

  // required int32 generator = 6;
  inline bool has_generator() const;
  inline void clear_generator();
  static const int kGeneratorFieldNumber = 6;
  inline ::google::protobuf::int32 generator() const;
  inline void set_generator(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.Prm300)
 private:
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_attenuator1();
  inline void clear_has_attenuator1();
  inline void set_has_attenuator2();
  inline void clear_has_attenuator2();
  inline void set_has_channum();
  inline void clear_has_channum();
  inline void set_has_generator();
  inline void clear_has_generator();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 freq_;
  ::google::protobuf::int32 filter_;
  ::google::protobuf::int32 attenuator1_;
  ::google::protobuf::int32 attenuator2_;
  ::google::protobuf::int32 channum_;
  ::google::protobuf::int32 generator_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Prm300* default_instance_;
};
// -------------------------------------------------------------------

class SmolenskRpu : public ::google::protobuf::MessageLite {
 public:
  SmolenskRpu();
  virtual ~SmolenskRpu();

  SmolenskRpu(const SmolenskRpu& from);

  inline SmolenskRpu& operator=(const SmolenskRpu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SmolenskRpu& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SmolenskRpu* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SmolenskRpu* other);

  // implements Message ----------------------------------------------

  SmolenskRpu* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SmolenskRpu& from);
  void MergeFrom(const SmolenskRpu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 freq = 1;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 1;
  inline ::google::protobuf::int32 freq() const;
  inline void set_freq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.SmolenskRpu)
 private:
  inline void set_has_freq();
  inline void clear_has_freq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 freq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static SmolenskRpu* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverOptions : public ::google::protobuf::MessageLite {
 public:
  ReceiverOptions();
  virtual ~ReceiverOptions();

  ReceiverOptions(const ReceiverOptions& from);

  inline ReceiverOptions& operator=(const ReceiverOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReceiverOptions& default_instance();

  enum ReceiverTypeCase {
    kSettingsPrm300 = 6,
    kSettingsSmolenskRpu = 7,
    RECEIVERTYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReceiverOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReceiverOptions* other);

  // implements Message ----------------------------------------------

  ReceiverOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReceiverOptions& from);
  void MergeFrom(const ReceiverOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .RdsProtobuf.Prm300 settingsPrm300 = 6;
  inline bool has_settingsprm300() const;
  inline void clear_settingsprm300();
  static const int kSettingsPrm300FieldNumber = 6;
  inline const ::RdsProtobuf::Prm300& settingsprm300() const;
  inline ::RdsProtobuf::Prm300* mutable_settingsprm300();
  inline ::RdsProtobuf::Prm300* release_settingsprm300();
  inline void set_allocated_settingsprm300(::RdsProtobuf::Prm300* settingsprm300);

  // optional .RdsProtobuf.SmolenskRpu settingsSmolenskRpu = 7;
  inline bool has_settingssmolenskrpu() const;
  inline void clear_settingssmolenskrpu();
  static const int kSettingsSmolenskRpuFieldNumber = 7;
  inline const ::RdsProtobuf::SmolenskRpu& settingssmolenskrpu() const;
  inline ::RdsProtobuf::SmolenskRpu* mutable_settingssmolenskrpu();
  inline ::RdsProtobuf::SmolenskRpu* release_settingssmolenskrpu();
  inline void set_allocated_settingssmolenskrpu(::RdsProtobuf::SmolenskRpu* settingssmolenskrpu);

  inline ReceiverTypeCase ReceiverType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ReceiverOptions)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_settingsprm300();
  inline void set_has_settingssmolenskrpu();

  inline bool has_ReceiverType();
  void clear_ReceiverType();
  inline void clear_has_ReceiverType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* ip_;
  bool status_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 type_;
  union ReceiverTypeUnion {
    ::RdsProtobuf::Prm300* settingsprm300_;
    ::RdsProtobuf::SmolenskRpu* settingssmolenskrpu_;
  } ReceiverType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ReceiverOptions* default_instance_;
};
// -------------------------------------------------------------------

class ChannelOptions : public ::google::protobuf::MessageLite {
 public:
  ChannelOptions();
  virtual ~ChannelOptions();

  ChannelOptions(const ChannelOptions& from);

  inline ChannelOptions& operator=(const ChannelOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChannelOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChannelOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChannelOptions* other);

  // implements Message ----------------------------------------------

  ChannelOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChannelOptions& from);
  void MergeFrom(const ChannelOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required bool inversion = 2;
  inline bool has_inversion() const;
  inline void clear_inversion();
  static const int kInversionFieldNumber = 2;
  inline bool inversion() const;
  inline void set_inversion(bool value);

  // required .RdsProtobuf.ReceiverOptions receiver = 3;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 3;
  inline const ::RdsProtobuf::ReceiverOptions& receiver() const;
  inline ::RdsProtobuf::ReceiverOptions* mutable_receiver();
  inline ::RdsProtobuf::ReceiverOptions* release_receiver();
  inline void set_allocated_receiver(::RdsProtobuf::ReceiverOptions* receiver);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.ChannelOptions)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_inversion();
  inline void clear_has_inversion();
  inline void set_has_receiver();
  inline void clear_has_receiver();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::RdsProtobuf::ReceiverOptions* receiver_;
  bool inversion_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ChannelOptions* default_instance_;
};
// -------------------------------------------------------------------

class DeviceOptions : public ::google::protobuf::MessageLite {
 public:
  DeviceOptions();
  virtual ~DeviceOptions();

  DeviceOptions(const DeviceOptions& from);

  inline DeviceOptions& operator=(const DeviceOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeviceOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceOptions* other);

  // implements Message ----------------------------------------------

  DeviceOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceOptions& from);
  void MergeFrom(const DeviceOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 portSCTP = 4;
  inline bool has_portsctp() const;
  inline void clear_portsctp();
  static const int kPortSCTPFieldNumber = 4;
  inline ::google::protobuf::int32 portsctp() const;
  inline void set_portsctp(::google::protobuf::int32 value);

  // required int32 portHTTP = 5;
  inline bool has_porthttp() const;
  inline void clear_porthttp();
  static const int kPortHTTPFieldNumber = 5;
  inline ::google::protobuf::int32 porthttp() const;
  inline void set_porthttp(::google::protobuf::int32 value);

  // required int32 channelsNum = 6;
  inline bool has_channelsnum() const;
  inline void clear_channelsnum();
  static const int kChannelsNumFieldNumber = 6;
  inline ::google::protobuf::int32 channelsnum() const;
  inline void set_channelsnum(::google::protobuf::int32 value);

  // required int32 sync = 7;
  inline bool has_sync() const;
  inline void clear_sync();
  static const int kSyncFieldNumber = 7;
  inline ::google::protobuf::int32 sync() const;
  inline void set_sync(::google::protobuf::int32 value);

  // required int32 board = 8;
  inline bool has_board() const;
  inline void clear_board();
  static const int kBoardFieldNumber = 8;
  inline ::google::protobuf::int32 board() const;
  inline void set_board(::google::protobuf::int32 value);

  // repeated .RdsProtobuf.ChannelOptions channels = 9;
  inline int channels_size() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 9;
  inline const ::RdsProtobuf::ChannelOptions& channels(int index) const;
  inline ::RdsProtobuf::ChannelOptions* mutable_channels(int index);
  inline ::RdsProtobuf::ChannelOptions* add_channels();
  inline const ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ChannelOptions >&
      channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ChannelOptions >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:RdsProtobuf.DeviceOptions)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_portsctp();
  inline void clear_has_portsctp();
  inline void set_has_porthttp();
  inline void clear_has_porthttp();
  inline void set_has_channelsnum();
  inline void clear_has_channelsnum();
  inline void set_has_sync();
  inline void clear_has_sync();
  inline void set_has_board();
  inline void clear_has_board();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* ip_;
  bool status_;
  ::google::protobuf::int32 portsctp_;
  ::google::protobuf::int32 porthttp_;
  ::google::protobuf::int32 channelsnum_;
  ::google::protobuf::int32 sync_;
  ::google::protobuf::int32 board_;
  ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ChannelOptions > channels_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceOptions* default_instance_;
};
// -------------------------------------------------------------------

class TimeFreqArea : public ::google::protobuf::MessageLite {
 public:
  TimeFreqArea();
  virtual ~TimeFreqArea();

  TimeFreqArea(const TimeFreqArea& from);

  inline TimeFreqArea& operator=(const TimeFreqArea& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TimeFreqArea& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeFreqArea* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeFreqArea* other);

  // implements Message ----------------------------------------------

  TimeFreqArea* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeFreqArea& from);
  void MergeFrom(const TimeFreqArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float time_start = 1;
  inline bool has_time_start() const;
  inline void clear_time_start();
  static const int kTimeStartFieldNumber = 1;
  inline float time_start() const;
  inline void set_time_start(float value);

  // required float time_end = 2;
  inline bool has_time_end() const;
  inline void clear_time_end();
  static const int kTimeEndFieldNumber = 2;
  inline float time_end() const;
  inline void set_time_end(float value);

  // required float freq_start = 3;
  inline bool has_freq_start() const;
  inline void clear_freq_start();
  static const int kFreqStartFieldNumber = 3;
  inline float freq_start() const;
  inline void set_freq_start(float value);

  // required float freq_end = 4;
  inline bool has_freq_end() const;
  inline void clear_freq_end();
  static const int kFreqEndFieldNumber = 4;
  inline float freq_end() const;
  inline void set_freq_end(float value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.TimeFreqArea)
 private:
  inline void set_has_time_start();
  inline void clear_has_time_start();
  inline void set_has_time_end();
  inline void clear_has_time_end();
  inline void set_has_freq_start();
  inline void clear_has_freq_start();
  inline void set_has_freq_end();
  inline void clear_has_freq_end();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float time_start_;
  float time_end_;
  float freq_start_;
  float freq_end_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static TimeFreqArea* default_instance_;
};
// -------------------------------------------------------------------

class Mode : public ::google::protobuf::MessageLite {
 public:
  Mode();
  virtual ~Mode();

  Mode(const Mode& from);

  inline Mode& operator=(const Mode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Mode& default_instance();

  enum MessageCase {
    kIndex = 1,
    kStatus = 2,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Mode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Mode* other);

  // implements Message ----------------------------------------------

  Mode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Mode& from);
  void MergeFrom(const Mode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.Mode)
 private:
  inline void set_has_index();
  inline void set_has_status();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::google::protobuf::int32 index_;
    bool status_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Mode* default_instance_;
};
// -------------------------------------------------------------------

class System_SystemOptions : public ::google::protobuf::MessageLite {
 public:
  System_SystemOptions();
  virtual ~System_SystemOptions();

  System_SystemOptions(const System_SystemOptions& from);

  inline System_SystemOptions& operator=(const System_SystemOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const System_SystemOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const System_SystemOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(System_SystemOptions* other);

  // implements Message ----------------------------------------------

  System_SystemOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const System_SystemOptions& from);
  void MergeFrom(const System_SystemOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required int32 devices_Num = 2;
  inline bool has_devices_num() const;
  inline void clear_devices_num();
  static const int kDevicesNumFieldNumber = 2;
  inline ::google::protobuf::int32 devices_num() const;
  inline void set_devices_num(::google::protobuf::int32 value);

  // repeated .RdsProtobuf.DeviceOptions devices = 3;
  inline int devices_size() const;
  inline void clear_devices();
  static const int kDevicesFieldNumber = 3;
  inline const ::RdsProtobuf::DeviceOptions& devices(int index) const;
  inline ::RdsProtobuf::DeviceOptions* mutable_devices(int index);
  inline ::RdsProtobuf::DeviceOptions* add_devices();
  inline const ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::DeviceOptions >&
      devices() const;
  inline ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::DeviceOptions >*
      mutable_devices();

  // required int32 separate_Receivers_Num = 4;
  inline bool has_separate_receivers_num() const;
  inline void clear_separate_receivers_num();
  static const int kSeparateReceiversNumFieldNumber = 4;
  inline ::google::protobuf::int32 separate_receivers_num() const;
  inline void set_separate_receivers_num(::google::protobuf::int32 value);

  // repeated .RdsProtobuf.ReceiverOptions separate_Receivers = 5;
  inline int separate_receivers_size() const;
  inline void clear_separate_receivers();
  static const int kSeparateReceiversFieldNumber = 5;
  inline const ::RdsProtobuf::ReceiverOptions& separate_receivers(int index) const;
  inline ::RdsProtobuf::ReceiverOptions* mutable_separate_receivers(int index);
  inline ::RdsProtobuf::ReceiverOptions* add_separate_receivers();
  inline const ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ReceiverOptions >&
      separate_receivers() const;
  inline ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ReceiverOptions >*
      mutable_separate_receivers();

  // @@protoc_insertion_point(class_scope:RdsProtobuf.System.SystemOptions)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_devices_num();
  inline void clear_has_devices_num();
  inline void set_has_separate_receivers_num();
  inline void clear_has_separate_receivers_num();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::DeviceOptions > devices_;
  ::google::protobuf::int32 devices_num_;
  ::google::protobuf::int32 separate_receivers_num_;
  ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ReceiverOptions > separate_receivers_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static System_SystemOptions* default_instance_;
};
// -------------------------------------------------------------------

class System_Device : public ::google::protobuf::MessageLite {
 public:
  System_Device();
  virtual ~System_Device();

  System_Device(const System_Device& from);

  inline System_Device& operator=(const System_Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const System_Device& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const System_Device* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(System_Device* other);

  // implements Message ----------------------------------------------

  System_Device* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const System_Device& from);
  void MergeFrom(const System_Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 device_Index = 1;
  inline bool has_device_index() const;
  inline void clear_device_index();
  static const int kDeviceIndexFieldNumber = 1;
  inline ::google::protobuf::int32 device_index() const;
  inline void set_device_index(::google::protobuf::int32 value);

  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.System.Device)
 private:
  inline void set_has_device_index();
  inline void clear_has_device_index();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 device_index_;
  bool status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static System_Device* default_instance_;
};
// -------------------------------------------------------------------

class System_Receiver : public ::google::protobuf::MessageLite {
 public:
  System_Receiver();
  virtual ~System_Receiver();

  System_Receiver(const System_Receiver& from);

  inline System_Receiver& operator=(const System_Receiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const System_Receiver& default_instance();

  enum MessageTypeCase {
    kStatus = 3,
    kSettingsPrm300 = 4,
    kSettingsSmolenskRpu = 5,
    MESSAGETYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const System_Receiver* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(System_Receiver* other);

  // implements Message ----------------------------------------------

  System_Receiver* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const System_Receiver& from);
  void MergeFrom(const System_Receiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 device_Index = 1;
  inline bool has_device_index() const;
  inline void clear_device_index();
  static const int kDeviceIndexFieldNumber = 1;
  inline ::google::protobuf::int32 device_index() const;
  inline void set_device_index(::google::protobuf::int32 value);

  // required int32 channel_Index = 2;
  inline bool has_channel_index() const;
  inline void clear_channel_index();
  static const int kChannelIndexFieldNumber = 2;
  inline ::google::protobuf::int32 channel_index() const;
  inline void set_channel_index(::google::protobuf::int32 value);

  // optional bool status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline bool status() const;
  inline void set_status(bool value);

  // optional .RdsProtobuf.Prm300 settingsPrm300 = 4;
  inline bool has_settingsprm300() const;
  inline void clear_settingsprm300();
  static const int kSettingsPrm300FieldNumber = 4;
  inline const ::RdsProtobuf::Prm300& settingsprm300() const;
  inline ::RdsProtobuf::Prm300* mutable_settingsprm300();
  inline ::RdsProtobuf::Prm300* release_settingsprm300();
  inline void set_allocated_settingsprm300(::RdsProtobuf::Prm300* settingsprm300);

  // optional .RdsProtobuf.SmolenskRpu settingsSmolenskRpu = 5;
  inline bool has_settingssmolenskrpu() const;
  inline void clear_settingssmolenskrpu();
  static const int kSettingsSmolenskRpuFieldNumber = 5;
  inline const ::RdsProtobuf::SmolenskRpu& settingssmolenskrpu() const;
  inline ::RdsProtobuf::SmolenskRpu* mutable_settingssmolenskrpu();
  inline ::RdsProtobuf::SmolenskRpu* release_settingssmolenskrpu();
  inline void set_allocated_settingssmolenskrpu(::RdsProtobuf::SmolenskRpu* settingssmolenskrpu);

  inline MessageTypeCase messageType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.System.Receiver)
 private:
  inline void set_has_device_index();
  inline void clear_has_device_index();
  inline void set_has_channel_index();
  inline void clear_has_channel_index();
  inline void set_has_status();
  inline void set_has_settingsprm300();
  inline void set_has_settingssmolenskrpu();

  inline bool has_messageType();
  void clear_messageType();
  inline void clear_has_messageType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 device_index_;
  ::google::protobuf::int32 channel_index_;
  union MessageTypeUnion {
    bool status_;
    ::RdsProtobuf::Prm300* settingsprm300_;
    ::RdsProtobuf::SmolenskRpu* settingssmolenskrpu_;
  } messageType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static System_Receiver* default_instance_;
};
// -------------------------------------------------------------------

class System_SeparateReceiver : public ::google::protobuf::MessageLite {
 public:
  System_SeparateReceiver();
  virtual ~System_SeparateReceiver();

  System_SeparateReceiver(const System_SeparateReceiver& from);

  inline System_SeparateReceiver& operator=(const System_SeparateReceiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const System_SeparateReceiver& default_instance();

  enum MessageTypeCase {
    kStatus = 2,
    kSettingsPrm300 = 4,
    kSettingsSmolenskRpu = 5,
    MESSAGETYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const System_SeparateReceiver* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(System_SeparateReceiver* other);

  // implements Message ----------------------------------------------

  System_SeparateReceiver* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const System_SeparateReceiver& from);
  void MergeFrom(const System_SeparateReceiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 receiver_Index = 1;
  inline bool has_receiver_index() const;
  inline void clear_receiver_index();
  static const int kReceiverIndexFieldNumber = 1;
  inline ::google::protobuf::int32 receiver_index() const;
  inline void set_receiver_index(::google::protobuf::int32 value);

  // optional bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // optional .RdsProtobuf.Prm300 settingsPrm300 = 4;
  inline bool has_settingsprm300() const;
  inline void clear_settingsprm300();
  static const int kSettingsPrm300FieldNumber = 4;
  inline const ::RdsProtobuf::Prm300& settingsprm300() const;
  inline ::RdsProtobuf::Prm300* mutable_settingsprm300();
  inline ::RdsProtobuf::Prm300* release_settingsprm300();
  inline void set_allocated_settingsprm300(::RdsProtobuf::Prm300* settingsprm300);

  // optional .RdsProtobuf.SmolenskRpu settingsSmolenskRpu = 5;
  inline bool has_settingssmolenskrpu() const;
  inline void clear_settingssmolenskrpu();
  static const int kSettingsSmolenskRpuFieldNumber = 5;
  inline const ::RdsProtobuf::SmolenskRpu& settingssmolenskrpu() const;
  inline ::RdsProtobuf::SmolenskRpu* mutable_settingssmolenskrpu();
  inline ::RdsProtobuf::SmolenskRpu* release_settingssmolenskrpu();
  inline void set_allocated_settingssmolenskrpu(::RdsProtobuf::SmolenskRpu* settingssmolenskrpu);

  inline MessageTypeCase messageType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.System.SeparateReceiver)
 private:
  inline void set_has_receiver_index();
  inline void clear_has_receiver_index();
  inline void set_has_status();
  inline void set_has_settingsprm300();
  inline void set_has_settingssmolenskrpu();

  inline bool has_messageType();
  void clear_messageType();
  inline void clear_has_messageType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 receiver_index_;
  union MessageTypeUnion {
    bool status_;
    ::RdsProtobuf::Prm300* settingsprm300_;
    ::RdsProtobuf::SmolenskRpu* settingssmolenskrpu_;
  } messageType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static System_SeparateReceiver* default_instance_;
};
// -------------------------------------------------------------------

class System : public ::google::protobuf::MessageLite {
 public:
  System();
  virtual ~System();

  System(const System& from);

  inline System& operator=(const System& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const System& default_instance();

  enum MessageCase {
    kOptions = 1,
    kDevice = 2,
    kReceiver = 3,
    kSeparateReceiver = 4,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const System* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(System* other);

  // implements Message ----------------------------------------------

  System* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const System& from);
  void MergeFrom(const System& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef System_SystemOptions SystemOptions;
  typedef System_Device Device;
  typedef System_Receiver Receiver;
  typedef System_SeparateReceiver SeparateReceiver;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.System.SystemOptions options = 1;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 1;
  inline const ::RdsProtobuf::System_SystemOptions& options() const;
  inline ::RdsProtobuf::System_SystemOptions* mutable_options();
  inline ::RdsProtobuf::System_SystemOptions* release_options();
  inline void set_allocated_options(::RdsProtobuf::System_SystemOptions* options);

  // optional .RdsProtobuf.System.Device device = 2;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 2;
  inline const ::RdsProtobuf::System_Device& device() const;
  inline ::RdsProtobuf::System_Device* mutable_device();
  inline ::RdsProtobuf::System_Device* release_device();
  inline void set_allocated_device(::RdsProtobuf::System_Device* device);

  // optional .RdsProtobuf.System.Receiver receiver = 3;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 3;
  inline const ::RdsProtobuf::System_Receiver& receiver() const;
  inline ::RdsProtobuf::System_Receiver* mutable_receiver();
  inline ::RdsProtobuf::System_Receiver* release_receiver();
  inline void set_allocated_receiver(::RdsProtobuf::System_Receiver* receiver);

  // optional .RdsProtobuf.System.SeparateReceiver separate_Receiver = 4;
  inline bool has_separate_receiver() const;
  inline void clear_separate_receiver();
  static const int kSeparateReceiverFieldNumber = 4;
  inline const ::RdsProtobuf::System_SeparateReceiver& separate_receiver() const;
  inline ::RdsProtobuf::System_SeparateReceiver* mutable_separate_receiver();
  inline ::RdsProtobuf::System_SeparateReceiver* release_separate_receiver();
  inline void set_allocated_separate_receiver(::RdsProtobuf::System_SeparateReceiver* separate_receiver);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.System)
 private:
  inline void set_has_options();
  inline void set_has_device();
  inline void set_has_receiver();
  inline void set_has_separate_receiver();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::RdsProtobuf::System_SystemOptions* options_;
    ::RdsProtobuf::System_Device* device_;
    ::RdsProtobuf::System_Receiver* receiver_;
    ::RdsProtobuf::System_SeparateReceiver* separate_receiver_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static System* default_instance_;
};
// -------------------------------------------------------------------

class Location_LocationOptions : public ::google::protobuf::MessageLite {
 public:
  Location_LocationOptions();
  virtual ~Location_LocationOptions();

  Location_LocationOptions(const Location_LocationOptions& from);

  inline Location_LocationOptions& operator=(const Location_LocationOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Location_LocationOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Location_LocationOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Location_LocationOptions* other);

  // implements Message ----------------------------------------------

  Location_LocationOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location_LocationOptions& from);
  void MergeFrom(const Location_LocationOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 chanNum = 1;
  inline bool has_channum() const;
  inline void clear_channum();
  static const int kChanNumFieldNumber = 1;
  inline ::google::protobuf::int32 channum() const;
  inline void set_channum(::google::protobuf::int32 value);

  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // required int32 baseIndex = 3;
  inline bool has_baseindex() const;
  inline void clear_baseindex();
  static const int kBaseIndexFieldNumber = 3;
  inline ::google::protobuf::int32 baseindex() const;
  inline void set_baseindex(::google::protobuf::int32 value);

  // required bool convolution = 4;
  inline bool has_convolution() const;
  inline void clear_convolution();
  static const int kConvolutionFieldNumber = 4;
  inline bool convolution() const;
  inline void set_convolution(bool value);

  // required int32 spectrumMean = 5;
  inline bool has_spectrummean() const;
  inline void clear_spectrummean();
  static const int kSpectrumMeanFieldNumber = 5;
  inline ::google::protobuf::int32 spectrummean() const;
  inline void set_spectrummean(::google::protobuf::int32 value);

  // required int32 tuningMode = 6;
  inline bool has_tuningmode() const;
  inline void clear_tuningmode();
  static const int kTuningModeFieldNumber = 6;
  inline ::google::protobuf::int32 tuningmode() const;
  inline void set_tuningmode(::google::protobuf::int32 value);

  // required int32 duration = 7;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 7;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // required int32 centralFreq = 8;
  inline bool has_centralfreq() const;
  inline void clear_centralfreq();
  static const int kCentralFreqFieldNumber = 8;
  inline ::google::protobuf::int32 centralfreq() const;
  inline void set_centralfreq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.Location.LocationOptions)
 private:
  inline void set_has_channum();
  inline void clear_has_channum();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_baseindex();
  inline void clear_has_baseindex();
  inline void set_has_convolution();
  inline void clear_has_convolution();
  inline void set_has_spectrummean();
  inline void clear_has_spectrummean();
  inline void set_has_tuningmode();
  inline void clear_has_tuningmode();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_centralfreq();
  inline void clear_has_centralfreq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 channum_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 baseindex_;
  bool convolution_;
  ::google::protobuf::int32 spectrummean_;
  ::google::protobuf::int32 tuningmode_;
  ::google::protobuf::int32 duration_;
  ::google::protobuf::int32 centralfreq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Location_LocationOptions* default_instance_;
};
// -------------------------------------------------------------------

class Location_FilterOptions : public ::google::protobuf::MessageLite {
 public:
  Location_FilterOptions();
  virtual ~Location_FilterOptions();

  Location_FilterOptions(const Location_FilterOptions& from);

  inline Location_FilterOptions& operator=(const Location_FilterOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Location_FilterOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Location_FilterOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Location_FilterOptions* other);

  // implements Message ----------------------------------------------

  Location_FilterOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location_FilterOptions& from);
  void MergeFrom(const Location_FilterOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 range = 1;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline ::google::protobuf::int32 range() const;
  inline void set_range(::google::protobuf::int32 value);

  // required int32 shift = 2;
  inline bool has_shift() const;
  inline void clear_shift();
  static const int kShiftFieldNumber = 2;
  inline ::google::protobuf::int32 shift() const;
  inline void set_shift(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.Location.FilterOptions)
 private:
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_shift();
  inline void clear_has_shift();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 range_;
  ::google::protobuf::int32 shift_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Location_FilterOptions* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::MessageLite {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Location& default_instance();

  enum MessageCase {
    kOptions = 1,
    kFilter = 2,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Location* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Location_LocationOptions LocationOptions;
  typedef Location_FilterOptions FilterOptions;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.Location.LocationOptions options = 1;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 1;
  inline const ::RdsProtobuf::Location_LocationOptions& options() const;
  inline ::RdsProtobuf::Location_LocationOptions* mutable_options();
  inline ::RdsProtobuf::Location_LocationOptions* release_options();
  inline void set_allocated_options(::RdsProtobuf::Location_LocationOptions* options);

  // optional .RdsProtobuf.Location.FilterOptions filter = 2;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 2;
  inline const ::RdsProtobuf::Location_FilterOptions& filter() const;
  inline ::RdsProtobuf::Location_FilterOptions* mutable_filter();
  inline ::RdsProtobuf::Location_FilterOptions* release_filter();
  inline void set_allocated_filter(::RdsProtobuf::Location_FilterOptions* filter);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.Location)
 private:
  inline void set_has_options();
  inline void set_has_filter();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::RdsProtobuf::Location_LocationOptions* options_;
    ::RdsProtobuf::Location_FilterOptions* filter_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class Detector_DetectorOptions : public ::google::protobuf::MessageLite {
 public:
  Detector_DetectorOptions();
  virtual ~Detector_DetectorOptions();

  Detector_DetectorOptions(const Detector_DetectorOptions& from);

  inline Detector_DetectorOptions& operator=(const Detector_DetectorOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Detector_DetectorOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Detector_DetectorOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Detector_DetectorOptions* other);

  // implements Message ----------------------------------------------

  Detector_DetectorOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Detector_DetectorOptions& from);
  void MergeFrom(const Detector_DetectorOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 chanNum = 1;
  inline bool has_channum() const;
  inline void clear_channum();
  static const int kChanNumFieldNumber = 1;
  inline ::google::protobuf::int32 channum() const;
  inline void set_channum(::google::protobuf::int32 value);

  // required int32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // required int32 startScanFreq = 3;
  inline bool has_startscanfreq() const;
  inline void clear_startscanfreq();
  static const int kStartScanFreqFieldNumber = 3;
  inline ::google::protobuf::int32 startscanfreq() const;
  inline void set_startscanfreq(::google::protobuf::int32 value);

  // required int32 endScanFreq = 4;
  inline bool has_endscanfreq() const;
  inline void clear_endscanfreq();
  static const int kEndScanFreqFieldNumber = 4;
  inline ::google::protobuf::int32 endscanfreq() const;
  inline void set_endscanfreq(::google::protobuf::int32 value);

  // required int32 loopNum = 5;
  inline bool has_loopnum() const;
  inline void clear_loopnum();
  static const int kLoopNumFieldNumber = 5;
  inline ::google::protobuf::int32 loopnum() const;
  inline void set_loopnum(::google::protobuf::int32 value);

  // required int32 spectrumMean = 6;
  inline bool has_spectrummean() const;
  inline void clear_spectrummean();
  static const int kSpectrumMeanFieldNumber = 6;
  inline ::google::protobuf::int32 spectrummean() const;
  inline void set_spectrummean(::google::protobuf::int32 value);

  // required bool convolution = 7;
  inline bool has_convolution() const;
  inline void clear_convolution();
  static const int kConvolutionFieldNumber = 7;
  inline bool convolution() const;
  inline void set_convolution(bool value);

  // required int32 veracityThreshold = 8;
  inline bool has_veracitythreshold() const;
  inline void clear_veracitythreshold();
  static const int kVeracityThresholdFieldNumber = 8;
  inline ::google::protobuf::int32 veracitythreshold() const;
  inline void set_veracitythreshold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.Detector.DetectorOptions)
 private:
  inline void set_has_channum();
  inline void clear_has_channum();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_startscanfreq();
  inline void clear_has_startscanfreq();
  inline void set_has_endscanfreq();
  inline void clear_has_endscanfreq();
  inline void set_has_loopnum();
  inline void clear_has_loopnum();
  inline void set_has_spectrummean();
  inline void clear_has_spectrummean();
  inline void set_has_convolution();
  inline void clear_has_convolution();
  inline void set_has_veracitythreshold();
  inline void clear_has_veracitythreshold();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 channum_;
  ::google::protobuf::int32 duration_;
  ::google::protobuf::int32 startscanfreq_;
  ::google::protobuf::int32 endscanfreq_;
  ::google::protobuf::int32 loopnum_;
  ::google::protobuf::int32 spectrummean_;
  bool convolution_;
  ::google::protobuf::int32 veracitythreshold_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Detector_DetectorOptions* default_instance_;
};
// -------------------------------------------------------------------

class Detector : public ::google::protobuf::MessageLite {
 public:
  Detector();
  virtual ~Detector();

  Detector(const Detector& from);

  inline Detector& operator=(const Detector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Detector& default_instance();

  enum MessageCase {
    kOptions = 1,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Detector* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Detector* other);

  // implements Message ----------------------------------------------

  Detector* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Detector& from);
  void MergeFrom(const Detector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Detector_DetectorOptions DetectorOptions;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.Detector.DetectorOptions options = 1;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 1;
  inline const ::RdsProtobuf::Detector_DetectorOptions& options() const;
  inline ::RdsProtobuf::Detector_DetectorOptions* mutable_options();
  inline ::RdsProtobuf::Detector_DetectorOptions* release_options();
  inline void set_allocated_options(::RdsProtobuf::Detector_DetectorOptions* options);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.Detector)
 private:
  inline void set_has_options();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::RdsProtobuf::Detector_DetectorOptions* options_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Detector* default_instance_;
};
// -------------------------------------------------------------------

class Analysis_AnalysisOptions : public ::google::protobuf::MessageLite {
 public:
  Analysis_AnalysisOptions();
  virtual ~Analysis_AnalysisOptions();

  Analysis_AnalysisOptions(const Analysis_AnalysisOptions& from);

  inline Analysis_AnalysisOptions& operator=(const Analysis_AnalysisOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Analysis_AnalysisOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Analysis_AnalysisOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Analysis_AnalysisOptions* other);

  // implements Message ----------------------------------------------

  Analysis_AnalysisOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Analysis_AnalysisOptions& from);
  void MergeFrom(const Analysis_AnalysisOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 chanIndex = 1;
  inline bool has_chanindex() const;
  inline void clear_chanindex();
  static const int kChanIndexFieldNumber = 1;
  inline ::google::protobuf::int32 chanindex() const;
  inline void set_chanindex(::google::protobuf::int32 value);

  // required int32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // required int32 centralFreq = 3;
  inline bool has_centralfreq() const;
  inline void clear_centralfreq();
  static const int kCentralFreqFieldNumber = 3;
  inline ::google::protobuf::int32 centralfreq() const;
  inline void set_centralfreq(::google::protobuf::int32 value);

  // required .RdsProtobuf.TimeFreqArea selected = 4;
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 4;
  inline const ::RdsProtobuf::TimeFreqArea& selected() const;
  inline ::RdsProtobuf::TimeFreqArea* mutable_selected();
  inline ::RdsProtobuf::TimeFreqArea* release_selected();
  inline void set_allocated_selected(::RdsProtobuf::TimeFreqArea* selected);

  // required .RdsProtobuf.TimeFreqArea zoomed = 5;
  inline bool has_zoomed() const;
  inline void clear_zoomed();
  static const int kZoomedFieldNumber = 5;
  inline const ::RdsProtobuf::TimeFreqArea& zoomed() const;
  inline ::RdsProtobuf::TimeFreqArea* mutable_zoomed();
  inline ::RdsProtobuf::TimeFreqArea* release_zoomed();
  inline void set_allocated_zoomed(::RdsProtobuf::TimeFreqArea* zoomed);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.Analysis.AnalysisOptions)
 private:
  inline void set_has_chanindex();
  inline void clear_has_chanindex();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_centralfreq();
  inline void clear_has_centralfreq();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_zoomed();
  inline void clear_has_zoomed();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 chanindex_;
  ::google::protobuf::int32 duration_;
  ::RdsProtobuf::TimeFreqArea* selected_;
  ::RdsProtobuf::TimeFreqArea* zoomed_;
  ::google::protobuf::int32 centralfreq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Analysis_AnalysisOptions* default_instance_;
};
// -------------------------------------------------------------------

class Analysis : public ::google::protobuf::MessageLite {
 public:
  Analysis();
  virtual ~Analysis();

  Analysis(const Analysis& from);

  inline Analysis& operator=(const Analysis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Analysis& default_instance();

  enum MessageCase {
    kOptions = 1,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Analysis* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Analysis* other);

  // implements Message ----------------------------------------------

  Analysis* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Analysis& from);
  void MergeFrom(const Analysis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Analysis_AnalysisOptions AnalysisOptions;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.Analysis.AnalysisOptions options = 1;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 1;
  inline const ::RdsProtobuf::Analysis_AnalysisOptions& options() const;
  inline ::RdsProtobuf::Analysis_AnalysisOptions* mutable_options();
  inline ::RdsProtobuf::Analysis_AnalysisOptions* release_options();
  inline void set_allocated_options(::RdsProtobuf::Analysis_AnalysisOptions* options);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.Analysis)
 private:
  inline void set_has_options();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::RdsProtobuf::Analysis_AnalysisOptions* options_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Analysis* default_instance_;
};
// -------------------------------------------------------------------

class DataStatus : public ::google::protobuf::MessageLite {
 public:
  DataStatus();
  virtual ~DataStatus();

  DataStatus(const DataStatus& from);

  inline DataStatus& operator=(const DataStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataStatus* other);

  // implements Message ----------------------------------------------

  DataStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataStatus& from);
  void MergeFrom(const DataStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool status = 1;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status(int index) const;
  inline void set_status(int index, bool value);
  inline void add_status(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      status() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_status();

  // required int32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.DataStatus)
 private:
  inline void set_has_length();
  inline void clear_has_length();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< bool > status_;
  ::google::protobuf::int32 length_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static DataStatus* default_instance_;
};
// -------------------------------------------------------------------

class LocationSpectrum : public ::google::protobuf::MessageLite {
 public:
  LocationSpectrum();
  virtual ~LocationSpectrum();

  LocationSpectrum(const LocationSpectrum& from);

  inline LocationSpectrum& operator=(const LocationSpectrum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LocationSpectrum& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationSpectrum* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationSpectrum* other);

  // implements Message ----------------------------------------------

  LocationSpectrum* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationSpectrum& from);
  void MergeFrom(const LocationSpectrum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated float data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // required int32 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required double startFreq = 4;
  inline bool has_startfreq() const;
  inline void clear_startfreq();
  static const int kStartFreqFieldNumber = 4;
  inline double startfreq() const;
  inline void set_startfreq(double value);

  // required double stepFreq = 5;
  inline bool has_stepfreq() const;
  inline void clear_stepfreq();
  static const int kStepFreqFieldNumber = 5;
  inline double stepfreq() const;
  inline void set_stepfreq(double value);

  // required int32 freqShift = 6;
  inline bool has_freqshift() const;
  inline void clear_freqshift();
  static const int kFreqShiftFieldNumber = 6;
  inline ::google::protobuf::int32 freqshift() const;
  inline void set_freqshift(::google::protobuf::int32 value);

  // required int32 signalRange = 7;
  inline bool has_signalrange() const;
  inline void clear_signalrange();
  static const int kSignalRangeFieldNumber = 7;
  inline ::google::protobuf::int32 signalrange() const;
  inline void set_signalrange(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.LocationSpectrum)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_startfreq();
  inline void clear_has_startfreq();
  inline void set_has_stepfreq();
  inline void clear_has_stepfreq();
  inline void set_has_freqshift();
  inline void clear_has_freqshift();
  inline void set_has_signalrange();
  inline void clear_has_signalrange();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 length_;
  double startfreq_;
  double stepfreq_;
  ::google::protobuf::int32 freqshift_;
  ::google::protobuf::int32 signalrange_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static LocationSpectrum* default_instance_;
};
// -------------------------------------------------------------------

class LocationXCov : public ::google::protobuf::MessageLite {
 public:
  LocationXCov();
  virtual ~LocationXCov();

  LocationXCov(const LocationXCov& from);

  inline LocationXCov& operator=(const LocationXCov& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LocationXCov& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationXCov* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationXCov* other);

  // implements Message ----------------------------------------------

  LocationXCov* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationXCov& from);
  void MergeFrom(const LocationXCov& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated float data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // required float timeDiff = 3;
  inline bool has_timediff() const;
  inline void clear_timediff();
  static const int kTimeDiffFieldNumber = 3;
  inline float timediff() const;
  inline void set_timediff(float value);

  // required float veracity = 4;
  inline bool has_veracity() const;
  inline void clear_veracity();
  static const int kVeracityFieldNumber = 4;
  inline float veracity() const;
  inline void set_veracity(float value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.LocationXCov)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_timediff();
  inline void clear_has_timediff();
  inline void set_has_veracity();
  inline void clear_has_veracity();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  ::google::protobuf::int32 index_;
  float timediff_;
  float veracity_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static LocationXCov* default_instance_;
};
// -------------------------------------------------------------------

class DetectorSpectrum : public ::google::protobuf::MessageLite {
 public:
  DetectorSpectrum();
  virtual ~DetectorSpectrum();

  DetectorSpectrum(const DetectorSpectrum& from);

  inline DetectorSpectrum& operator=(const DetectorSpectrum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DetectorSpectrum& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetectorSpectrum* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetectorSpectrum* other);

  // implements Message ----------------------------------------------

  DetectorSpectrum* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetectorSpectrum& from);
  void MergeFrom(const DetectorSpectrum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated float data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // required int32 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required double startFreq = 4;
  inline bool has_startfreq() const;
  inline void clear_startfreq();
  static const int kStartFreqFieldNumber = 4;
  inline double startfreq() const;
  inline void set_startfreq(double value);

  // required double stepFreq = 5;
  inline bool has_stepfreq() const;
  inline void clear_stepfreq();
  static const int kStepFreqFieldNumber = 5;
  inline double stepfreq() const;
  inline void set_stepfreq(double value);

  // required int32 freqShift = 6;
  inline bool has_freqshift() const;
  inline void clear_freqshift();
  static const int kFreqShiftFieldNumber = 6;
  inline ::google::protobuf::int32 freqshift() const;
  inline void set_freqshift(::google::protobuf::int32 value);

  // required int32 signalRange = 7;
  inline bool has_signalrange() const;
  inline void clear_signalrange();
  static const int kSignalRangeFieldNumber = 7;
  inline ::google::protobuf::int32 signalrange() const;
  inline void set_signalrange(::google::protobuf::int32 value);

  // repeated int32 firstIndex = 8;
  inline int firstindex_size() const;
  inline void clear_firstindex();
  static const int kFirstIndexFieldNumber = 8;
  inline ::google::protobuf::int32 firstindex(int index) const;
  inline void set_firstindex(int index, ::google::protobuf::int32 value);
  inline void add_firstindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      firstindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_firstindex();

  // repeated int32 lastIndex = 9;
  inline int lastindex_size() const;
  inline void clear_lastindex();
  static const int kLastIndexFieldNumber = 9;
  inline ::google::protobuf::int32 lastindex(int index) const;
  inline void set_lastindex(int index, ::google::protobuf::int32 value);
  inline void add_lastindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lastindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lastindex();

  // required int32 detectedNum = 10;
  inline bool has_detectednum() const;
  inline void clear_detectednum();
  static const int kDetectedNumFieldNumber = 10;
  inline ::google::protobuf::int32 detectednum() const;
  inline void set_detectednum(::google::protobuf::int32 value);

  // required int32 centralFreq = 11;
  inline bool has_centralfreq() const;
  inline void clear_centralfreq();
  static const int kCentralFreqFieldNumber = 11;
  inline ::google::protobuf::int32 centralfreq() const;
  inline void set_centralfreq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.DetectorSpectrum)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_startfreq();
  inline void clear_has_startfreq();
  inline void set_has_stepfreq();
  inline void clear_has_stepfreq();
  inline void set_has_freqshift();
  inline void clear_has_freqshift();
  inline void set_has_signalrange();
  inline void clear_has_signalrange();
  inline void set_has_detectednum();
  inline void clear_has_detectednum();
  inline void set_has_centralfreq();
  inline void clear_has_centralfreq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 length_;
  double startfreq_;
  double stepfreq_;
  ::google::protobuf::int32 freqshift_;
  ::google::protobuf::int32 signalrange_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > firstindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lastindex_;
  ::google::protobuf::int32 detectednum_;
  ::google::protobuf::int32 centralfreq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static DetectorSpectrum* default_instance_;
};
// -------------------------------------------------------------------

class AnalysisSpectrogram : public ::google::protobuf::MessageLite {
 public:
  AnalysisSpectrogram();
  virtual ~AnalysisSpectrogram();

  AnalysisSpectrogram(const AnalysisSpectrogram& from);

  inline AnalysisSpectrogram& operator=(const AnalysisSpectrogram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnalysisSpectrogram& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnalysisSpectrogram* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnalysisSpectrogram* other);

  // implements Message ----------------------------------------------

  AnalysisSpectrogram* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnalysisSpectrogram& from);
  void MergeFrom(const AnalysisSpectrogram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // required int32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required int32 columns = 3;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 3;
  inline ::google::protobuf::int32 columns() const;
  inline void set_columns(::google::protobuf::int32 value);

  // required .RdsProtobuf.TimeFreqArea area = 4;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 4;
  inline const ::RdsProtobuf::TimeFreqArea& area() const;
  inline ::RdsProtobuf::TimeFreqArea* mutable_area();
  inline ::RdsProtobuf::TimeFreqArea* release_area();
  inline void set_allocated_area(::RdsProtobuf::TimeFreqArea* area);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.AnalysisSpectrogram)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_columns();
  inline void clear_has_columns();
  inline void set_has_area();
  inline void clear_has_area();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 columns_;
  ::RdsProtobuf::TimeFreqArea* area_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static AnalysisSpectrogram* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_GetMessage : public ::google::protobuf::MessageLite {
 public:
  ClientMessage_GetMessage();
  virtual ~ClientMessage_GetMessage();

  ClientMessage_GetMessage(const ClientMessage_GetMessage& from);

  inline ClientMessage_GetMessage& operator=(const ClientMessage_GetMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientMessage_GetMessage& default_instance();

  enum MessageCase {
    kMode = 1,
    kSystem = 2,
    kLocation = 3,
    kDetector = 4,
    kAnalysis = 5,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientMessage_GetMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientMessage_GetMessage* other);

  // implements Message ----------------------------------------------

  ClientMessage_GetMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMessage_GetMessage& from);
  void MergeFrom(const ClientMessage_GetMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.Mode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::RdsProtobuf::Mode& mode() const;
  inline ::RdsProtobuf::Mode* mutable_mode();
  inline ::RdsProtobuf::Mode* release_mode();
  inline void set_allocated_mode(::RdsProtobuf::Mode* mode);

  // optional .RdsProtobuf.System system = 2;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 2;
  inline const ::RdsProtobuf::System& system() const;
  inline ::RdsProtobuf::System* mutable_system();
  inline ::RdsProtobuf::System* release_system();
  inline void set_allocated_system(::RdsProtobuf::System* system);

  // optional .RdsProtobuf.Location location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::RdsProtobuf::Location& location() const;
  inline ::RdsProtobuf::Location* mutable_location();
  inline ::RdsProtobuf::Location* release_location();
  inline void set_allocated_location(::RdsProtobuf::Location* location);

  // optional .RdsProtobuf.Detector detector = 4;
  inline bool has_detector() const;
  inline void clear_detector();
  static const int kDetectorFieldNumber = 4;
  inline const ::RdsProtobuf::Detector& detector() const;
  inline ::RdsProtobuf::Detector* mutable_detector();
  inline ::RdsProtobuf::Detector* release_detector();
  inline void set_allocated_detector(::RdsProtobuf::Detector* detector);

  // optional .RdsProtobuf.Analysis analysis = 5;
  inline bool has_analysis() const;
  inline void clear_analysis();
  static const int kAnalysisFieldNumber = 5;
  inline const ::RdsProtobuf::Analysis& analysis() const;
  inline ::RdsProtobuf::Analysis* mutable_analysis();
  inline ::RdsProtobuf::Analysis* release_analysis();
  inline void set_allocated_analysis(::RdsProtobuf::Analysis* analysis);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ClientMessage.GetMessage)
 private:
  inline void set_has_mode();
  inline void set_has_system();
  inline void set_has_location();
  inline void set_has_detector();
  inline void set_has_analysis();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::RdsProtobuf::Mode* mode_;
    ::RdsProtobuf::System* system_;
    ::RdsProtobuf::Location* location_;
    ::RdsProtobuf::Detector* detector_;
    ::RdsProtobuf::Analysis* analysis_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_GetMessage* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_SetMessage : public ::google::protobuf::MessageLite {
 public:
  ClientMessage_SetMessage();
  virtual ~ClientMessage_SetMessage();

  ClientMessage_SetMessage(const ClientMessage_SetMessage& from);

  inline ClientMessage_SetMessage& operator=(const ClientMessage_SetMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientMessage_SetMessage& default_instance();

  enum MessageCase {
    kMode = 1,
    kSystem = 2,
    kLocation = 3,
    kDetector = 4,
    kAnalysis = 5,
    MESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientMessage_SetMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientMessage_SetMessage* other);

  // implements Message ----------------------------------------------

  ClientMessage_SetMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMessage_SetMessage& from);
  void MergeFrom(const ClientMessage_SetMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.Mode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::RdsProtobuf::Mode& mode() const;
  inline ::RdsProtobuf::Mode* mutable_mode();
  inline ::RdsProtobuf::Mode* release_mode();
  inline void set_allocated_mode(::RdsProtobuf::Mode* mode);

  // optional .RdsProtobuf.System system = 2;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 2;
  inline const ::RdsProtobuf::System& system() const;
  inline ::RdsProtobuf::System* mutable_system();
  inline ::RdsProtobuf::System* release_system();
  inline void set_allocated_system(::RdsProtobuf::System* system);

  // optional .RdsProtobuf.Location location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::RdsProtobuf::Location& location() const;
  inline ::RdsProtobuf::Location* mutable_location();
  inline ::RdsProtobuf::Location* release_location();
  inline void set_allocated_location(::RdsProtobuf::Location* location);

  // optional .RdsProtobuf.Detector detector = 4;
  inline bool has_detector() const;
  inline void clear_detector();
  static const int kDetectorFieldNumber = 4;
  inline const ::RdsProtobuf::Detector& detector() const;
  inline ::RdsProtobuf::Detector* mutable_detector();
  inline ::RdsProtobuf::Detector* release_detector();
  inline void set_allocated_detector(::RdsProtobuf::Detector* detector);

  // optional .RdsProtobuf.Analysis analysis = 5;
  inline bool has_analysis() const;
  inline void clear_analysis();
  static const int kAnalysisFieldNumber = 5;
  inline const ::RdsProtobuf::Analysis& analysis() const;
  inline ::RdsProtobuf::Analysis* mutable_analysis();
  inline ::RdsProtobuf::Analysis* release_analysis();
  inline void set_allocated_analysis(::RdsProtobuf::Analysis* analysis);

  inline MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ClientMessage.SetMessage)
 private:
  inline void set_has_mode();
  inline void set_has_system();
  inline void set_has_location();
  inline void set_has_detector();
  inline void set_has_analysis();

  inline bool has_Message();
  void clear_Message();
  inline void clear_has_Message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::RdsProtobuf::Mode* mode_;
    ::RdsProtobuf::System* system_;
    ::RdsProtobuf::Location* location_;
    ::RdsProtobuf::Detector* detector_;
    ::RdsProtobuf::Analysis* analysis_;
  } Message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_SetMessage* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::MessageLite {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientMessage& default_instance();

  enum MessageTypeCase {
    kGet = 1,
    kSet = 2,
    MESSAGETYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientMessage* other);

  // implements Message ----------------------------------------------

  ClientMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientMessage_GetMessage GetMessage;
  typedef ClientMessage_SetMessage SetMessage;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.ClientMessage.GetMessage get = 1;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 1;
  inline const ::RdsProtobuf::ClientMessage_GetMessage& get() const;
  inline ::RdsProtobuf::ClientMessage_GetMessage* mutable_get();
  inline ::RdsProtobuf::ClientMessage_GetMessage* release_get();
  inline void set_allocated_get(::RdsProtobuf::ClientMessage_GetMessage* get);

  // optional .RdsProtobuf.ClientMessage.SetMessage set = 2;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 2;
  inline const ::RdsProtobuf::ClientMessage_SetMessage& set() const;
  inline ::RdsProtobuf::ClientMessage_SetMessage* mutable_set();
  inline ::RdsProtobuf::ClientMessage_SetMessage* release_set();
  inline void set_allocated_set(::RdsProtobuf::ClientMessage_SetMessage* set);

  inline MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ClientMessage)
 private:
  inline void set_has_get();
  inline void set_has_set();

  inline bool has_MessageType();
  void clear_MessageType();
  inline void clear_has_MessageType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageTypeUnion {
    ::RdsProtobuf::ClientMessage_GetMessage* get_;
    ::RdsProtobuf::ClientMessage_SetMessage* set_;
  } MessageType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage_CurrentMessage : public ::google::protobuf::MessageLite {
 public:
  ServerMessage_CurrentMessage();
  virtual ~ServerMessage_CurrentMessage();

  ServerMessage_CurrentMessage(const ServerMessage_CurrentMessage& from);

  inline ServerMessage_CurrentMessage& operator=(const ServerMessage_CurrentMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMessage_CurrentMessage& default_instance();

  enum RequestCase {
    kMode = 1,
    kSystem = 2,
    kLocation = 3,
    kDetector = 4,
    kAnalysis = 5,
    REQUEST_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMessage_CurrentMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMessage_CurrentMessage* other);

  // implements Message ----------------------------------------------

  ServerMessage_CurrentMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMessage_CurrentMessage& from);
  void MergeFrom(const ServerMessage_CurrentMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.Mode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::RdsProtobuf::Mode& mode() const;
  inline ::RdsProtobuf::Mode* mutable_mode();
  inline ::RdsProtobuf::Mode* release_mode();
  inline void set_allocated_mode(::RdsProtobuf::Mode* mode);

  // optional .RdsProtobuf.System system = 2;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 2;
  inline const ::RdsProtobuf::System& system() const;
  inline ::RdsProtobuf::System* mutable_system();
  inline ::RdsProtobuf::System* release_system();
  inline void set_allocated_system(::RdsProtobuf::System* system);

  // optional .RdsProtobuf.Location location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::RdsProtobuf::Location& location() const;
  inline ::RdsProtobuf::Location* mutable_location();
  inline ::RdsProtobuf::Location* release_location();
  inline void set_allocated_location(::RdsProtobuf::Location* location);

  // optional .RdsProtobuf.Detector detector = 4;
  inline bool has_detector() const;
  inline void clear_detector();
  static const int kDetectorFieldNumber = 4;
  inline const ::RdsProtobuf::Detector& detector() const;
  inline ::RdsProtobuf::Detector* mutable_detector();
  inline ::RdsProtobuf::Detector* release_detector();
  inline void set_allocated_detector(::RdsProtobuf::Detector* detector);

  // optional .RdsProtobuf.Analysis analysis = 5;
  inline bool has_analysis() const;
  inline void clear_analysis();
  static const int kAnalysisFieldNumber = 5;
  inline const ::RdsProtobuf::Analysis& analysis() const;
  inline ::RdsProtobuf::Analysis* mutable_analysis();
  inline ::RdsProtobuf::Analysis* release_analysis();
  inline void set_allocated_analysis(::RdsProtobuf::Analysis* analysis);

  inline RequestCase Request_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ServerMessage.CurrentMessage)
 private:
  inline void set_has_mode();
  inline void set_has_system();
  inline void set_has_location();
  inline void set_has_detector();
  inline void set_has_analysis();

  inline bool has_Request();
  void clear_Request();
  inline void clear_has_Request();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union RequestUnion {
    ::RdsProtobuf::Mode* mode_;
    ::RdsProtobuf::System* system_;
    ::RdsProtobuf::Location* location_;
    ::RdsProtobuf::Detector* detector_;
    ::RdsProtobuf::Analysis* analysis_;
  } Request_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage_CurrentMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage_DataMessage : public ::google::protobuf::MessageLite {
 public:
  ServerMessage_DataMessage();
  virtual ~ServerMessage_DataMessage();

  ServerMessage_DataMessage(const ServerMessage_DataMessage& from);

  inline ServerMessage_DataMessage& operator=(const ServerMessage_DataMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMessage_DataMessage& default_instance();

  enum RequestTypeCase {
    kLocationSpectrum = 1,
    kLocationXCov = 2,
    kDataStatus = 3,
    kDetectorSpectrum = 4,
    kAnalysisSpectrogram = 5,
    REQUESTTYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMessage_DataMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMessage_DataMessage* other);

  // implements Message ----------------------------------------------

  ServerMessage_DataMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMessage_DataMessage& from);
  void MergeFrom(const ServerMessage_DataMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.LocationSpectrum location_Spectrum = 1;
  inline bool has_location_spectrum() const;
  inline void clear_location_spectrum();
  static const int kLocationSpectrumFieldNumber = 1;
  inline const ::RdsProtobuf::LocationSpectrum& location_spectrum() const;
  inline ::RdsProtobuf::LocationSpectrum* mutable_location_spectrum();
  inline ::RdsProtobuf::LocationSpectrum* release_location_spectrum();
  inline void set_allocated_location_spectrum(::RdsProtobuf::LocationSpectrum* location_spectrum);

  // optional .RdsProtobuf.LocationXCov location_XCov = 2;
  inline bool has_location_xcov() const;
  inline void clear_location_xcov();
  static const int kLocationXCovFieldNumber = 2;
  inline const ::RdsProtobuf::LocationXCov& location_xcov() const;
  inline ::RdsProtobuf::LocationXCov* mutable_location_xcov();
  inline ::RdsProtobuf::LocationXCov* release_location_xcov();
  inline void set_allocated_location_xcov(::RdsProtobuf::LocationXCov* location_xcov);

  // optional .RdsProtobuf.DataStatus data_Status = 3;
  inline bool has_data_status() const;
  inline void clear_data_status();
  static const int kDataStatusFieldNumber = 3;
  inline const ::RdsProtobuf::DataStatus& data_status() const;
  inline ::RdsProtobuf::DataStatus* mutable_data_status();
  inline ::RdsProtobuf::DataStatus* release_data_status();
  inline void set_allocated_data_status(::RdsProtobuf::DataStatus* data_status);

  // optional .RdsProtobuf.DetectorSpectrum detector_Spectrum = 4;
  inline bool has_detector_spectrum() const;
  inline void clear_detector_spectrum();
  static const int kDetectorSpectrumFieldNumber = 4;
  inline const ::RdsProtobuf::DetectorSpectrum& detector_spectrum() const;
  inline ::RdsProtobuf::DetectorSpectrum* mutable_detector_spectrum();
  inline ::RdsProtobuf::DetectorSpectrum* release_detector_spectrum();
  inline void set_allocated_detector_spectrum(::RdsProtobuf::DetectorSpectrum* detector_spectrum);

  // optional .RdsProtobuf.AnalysisSpectrogram analysis_Spectrogram = 5;
  inline bool has_analysis_spectrogram() const;
  inline void clear_analysis_spectrogram();
  static const int kAnalysisSpectrogramFieldNumber = 5;
  inline const ::RdsProtobuf::AnalysisSpectrogram& analysis_spectrogram() const;
  inline ::RdsProtobuf::AnalysisSpectrogram* mutable_analysis_spectrogram();
  inline ::RdsProtobuf::AnalysisSpectrogram* release_analysis_spectrogram();
  inline void set_allocated_analysis_spectrogram(::RdsProtobuf::AnalysisSpectrogram* analysis_spectrogram);

  inline RequestTypeCase RequestType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ServerMessage.DataMessage)
 private:
  inline void set_has_location_spectrum();
  inline void set_has_location_xcov();
  inline void set_has_data_status();
  inline void set_has_detector_spectrum();
  inline void set_has_analysis_spectrogram();

  inline bool has_RequestType();
  void clear_RequestType();
  inline void clear_has_RequestType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union RequestTypeUnion {
    ::RdsProtobuf::LocationSpectrum* location_spectrum_;
    ::RdsProtobuf::LocationXCov* location_xcov_;
    ::RdsProtobuf::DataStatus* data_status_;
    ::RdsProtobuf::DetectorSpectrum* detector_spectrum_;
    ::RdsProtobuf::AnalysisSpectrogram* analysis_spectrogram_;
  } RequestType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage_DataMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage_AnswerMessage_Error : public ::google::protobuf::MessageLite {
 public:
  ServerMessage_AnswerMessage_Error();
  virtual ~ServerMessage_AnswerMessage_Error();

  ServerMessage_AnswerMessage_Error(const ServerMessage_AnswerMessage_Error& from);

  inline ServerMessage_AnswerMessage_Error& operator=(const ServerMessage_AnswerMessage_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMessage_AnswerMessage_Error& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMessage_AnswerMessage_Error* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMessage_AnswerMessage_Error* other);

  // implements Message ----------------------------------------------

  ServerMessage_AnswerMessage_Error* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMessage_AnswerMessage_Error& from);
  void MergeFrom(const ServerMessage_AnswerMessage_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.ServerMessage.AnswerMessage.Error)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* str_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage_AnswerMessage_Error* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage_AnswerMessage_Confirmation : public ::google::protobuf::MessageLite {
 public:
  ServerMessage_AnswerMessage_Confirmation();
  virtual ~ServerMessage_AnswerMessage_Confirmation();

  ServerMessage_AnswerMessage_Confirmation(const ServerMessage_AnswerMessage_Confirmation& from);

  inline ServerMessage_AnswerMessage_Confirmation& operator=(const ServerMessage_AnswerMessage_Confirmation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMessage_AnswerMessage_Confirmation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMessage_AnswerMessage_Confirmation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMessage_AnswerMessage_Confirmation* other);

  // implements Message ----------------------------------------------

  ServerMessage_AnswerMessage_Confirmation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMessage_AnswerMessage_Confirmation& from);
  void MergeFrom(const ServerMessage_AnswerMessage_Confirmation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* str_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage_AnswerMessage_Confirmation* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage_AnswerMessage : public ::google::protobuf::MessageLite {
 public:
  ServerMessage_AnswerMessage();
  virtual ~ServerMessage_AnswerMessage();

  ServerMessage_AnswerMessage(const ServerMessage_AnswerMessage& from);

  inline ServerMessage_AnswerMessage& operator=(const ServerMessage_AnswerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMessage_AnswerMessage& default_instance();

  enum RequestTypeCase {
    kError = 1,
    kConfirmation = 2,
    REQUESTTYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMessage_AnswerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMessage_AnswerMessage* other);

  // implements Message ----------------------------------------------

  ServerMessage_AnswerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMessage_AnswerMessage& from);
  void MergeFrom(const ServerMessage_AnswerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ServerMessage_AnswerMessage_Error Error;
  typedef ServerMessage_AnswerMessage_Confirmation Confirmation;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.ServerMessage.AnswerMessage.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::RdsProtobuf::ServerMessage_AnswerMessage_Error& error() const;
  inline ::RdsProtobuf::ServerMessage_AnswerMessage_Error* mutable_error();
  inline ::RdsProtobuf::ServerMessage_AnswerMessage_Error* release_error();
  inline void set_allocated_error(::RdsProtobuf::ServerMessage_AnswerMessage_Error* error);

  // optional .RdsProtobuf.ServerMessage.AnswerMessage.Confirmation confirmation = 2;
  inline bool has_confirmation() const;
  inline void clear_confirmation();
  static const int kConfirmationFieldNumber = 2;
  inline const ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation& confirmation() const;
  inline ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* mutable_confirmation();
  inline ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* release_confirmation();
  inline void set_allocated_confirmation(::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* confirmation);

  inline RequestTypeCase RequestType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ServerMessage.AnswerMessage)
 private:
  inline void set_has_error();
  inline void set_has_confirmation();

  inline bool has_RequestType();
  void clear_RequestType();
  inline void clear_has_RequestType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union RequestTypeUnion {
    ::RdsProtobuf::ServerMessage_AnswerMessage_Error* error_;
    ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* confirmation_;
  } RequestType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage_AnswerMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::MessageLite {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerMessage& default_instance();

  enum MessageTypeCase {
    kCurrent = 1,
    kData = 2,
    kAnswer = 3,
    MESSAGETYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerMessage* other);

  // implements Message ----------------------------------------------

  ServerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ServerMessage_CurrentMessage CurrentMessage;
  typedef ServerMessage_DataMessage DataMessage;
  typedef ServerMessage_AnswerMessage AnswerMessage;

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.ServerMessage.CurrentMessage current = 1;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 1;
  inline const ::RdsProtobuf::ServerMessage_CurrentMessage& current() const;
  inline ::RdsProtobuf::ServerMessage_CurrentMessage* mutable_current();
  inline ::RdsProtobuf::ServerMessage_CurrentMessage* release_current();
  inline void set_allocated_current(::RdsProtobuf::ServerMessage_CurrentMessage* current);

  // optional .RdsProtobuf.ServerMessage.DataMessage data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::RdsProtobuf::ServerMessage_DataMessage& data() const;
  inline ::RdsProtobuf::ServerMessage_DataMessage* mutable_data();
  inline ::RdsProtobuf::ServerMessage_DataMessage* release_data();
  inline void set_allocated_data(::RdsProtobuf::ServerMessage_DataMessage* data);

  // optional .RdsProtobuf.ServerMessage.AnswerMessage answer = 3;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 3;
  inline const ::RdsProtobuf::ServerMessage_AnswerMessage& answer() const;
  inline ::RdsProtobuf::ServerMessage_AnswerMessage* mutable_answer();
  inline ::RdsProtobuf::ServerMessage_AnswerMessage* release_answer();
  inline void set_allocated_answer(::RdsProtobuf::ServerMessage_AnswerMessage* answer);

  inline MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.ServerMessage)
 private:
  inline void set_has_current();
  inline void set_has_data();
  inline void set_has_answer();

  inline bool has_MessageType();
  void clear_MessageType();
  inline void clear_has_MessageType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageTypeUnion {
    ::RdsProtobuf::ServerMessage_CurrentMessage* current_;
    ::RdsProtobuf::ServerMessage_DataMessage* data_;
    ::RdsProtobuf::ServerMessage_AnswerMessage* answer_;
  } MessageType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::MessageLite {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet& default_instance();

  enum PacketTypeCase {
    kFromClient = 1,
    kFromServer = 2,
    PACKETTYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  Packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RdsProtobuf.ClientMessage from_client = 1;
  inline bool has_from_client() const;
  inline void clear_from_client();
  static const int kFromClientFieldNumber = 1;
  inline const ::RdsProtobuf::ClientMessage& from_client() const;
  inline ::RdsProtobuf::ClientMessage* mutable_from_client();
  inline ::RdsProtobuf::ClientMessage* release_from_client();
  inline void set_allocated_from_client(::RdsProtobuf::ClientMessage* from_client);

  // optional .RdsProtobuf.ServerMessage from_server = 2;
  inline bool has_from_server() const;
  inline void clear_from_server();
  static const int kFromServerFieldNumber = 2;
  inline const ::RdsProtobuf::ServerMessage& from_server() const;
  inline ::RdsProtobuf::ServerMessage* mutable_from_server();
  inline ::RdsProtobuf::ServerMessage* release_from_server();
  inline void set_allocated_from_server(::RdsProtobuf::ServerMessage* from_server);

  inline PacketTypeCase PacketType_case() const;
  // @@protoc_insertion_point(class_scope:RdsProtobuf.Packet)
 private:
  inline void set_has_from_client();
  inline void set_has_from_server();

  inline bool has_PacketType();
  void clear_PacketType();
  inline void clear_has_PacketType();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union PacketTypeUnion {
    ::RdsProtobuf::ClientMessage* from_client_;
    ::RdsProtobuf::ServerMessage* from_server_;
  } PacketType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_RdsPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_RdsPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_RdsPacket_2eproto();
  friend void protobuf_ShutdownFile_RdsPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// ===================================================================


// ===================================================================

// Prm300

// required int32 freq = 1;
inline bool Prm300::has_freq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prm300::set_has_freq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prm300::clear_has_freq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prm300::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline ::google::protobuf::int32 Prm300::freq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Prm300.freq)
  return freq_;
}
inline void Prm300::set_freq(::google::protobuf::int32 value) {
  set_has_freq();
  freq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Prm300.freq)
}

// required int32 filter = 2;
inline bool Prm300::has_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prm300::set_has_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prm300::clear_has_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prm300::clear_filter() {
  filter_ = 0;
  clear_has_filter();
}
inline ::google::protobuf::int32 Prm300::filter() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Prm300.filter)
  return filter_;
}
inline void Prm300::set_filter(::google::protobuf::int32 value) {
  set_has_filter();
  filter_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Prm300.filter)
}

// required int32 attenuator1 = 3;
inline bool Prm300::has_attenuator1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Prm300::set_has_attenuator1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Prm300::clear_has_attenuator1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Prm300::clear_attenuator1() {
  attenuator1_ = 0;
  clear_has_attenuator1();
}
inline ::google::protobuf::int32 Prm300::attenuator1() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Prm300.attenuator1)
  return attenuator1_;
}
inline void Prm300::set_attenuator1(::google::protobuf::int32 value) {
  set_has_attenuator1();
  attenuator1_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Prm300.attenuator1)
}

// required int32 attenuator2 = 4;
inline bool Prm300::has_attenuator2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Prm300::set_has_attenuator2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Prm300::clear_has_attenuator2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Prm300::clear_attenuator2() {
  attenuator2_ = 0;
  clear_has_attenuator2();
}
inline ::google::protobuf::int32 Prm300::attenuator2() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Prm300.attenuator2)
  return attenuator2_;
}
inline void Prm300::set_attenuator2(::google::protobuf::int32 value) {
  set_has_attenuator2();
  attenuator2_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Prm300.attenuator2)
}

// required int32 chanNum = 5;
inline bool Prm300::has_channum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Prm300::set_has_channum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Prm300::clear_has_channum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Prm300::clear_channum() {
  channum_ = 0;
  clear_has_channum();
}
inline ::google::protobuf::int32 Prm300::channum() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Prm300.chanNum)
  return channum_;
}
inline void Prm300::set_channum(::google::protobuf::int32 value) {
  set_has_channum();
  channum_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Prm300.chanNum)
}

// required int32 generator = 6;
inline bool Prm300::has_generator() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Prm300::set_has_generator() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Prm300::clear_has_generator() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Prm300::clear_generator() {
  generator_ = 0;
  clear_has_generator();
}
inline ::google::protobuf::int32 Prm300::generator() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Prm300.generator)
  return generator_;
}
inline void Prm300::set_generator(::google::protobuf::int32 value) {
  set_has_generator();
  generator_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Prm300.generator)
}

// -------------------------------------------------------------------

// SmolenskRpu

// required int32 freq = 1;
inline bool SmolenskRpu::has_freq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmolenskRpu::set_has_freq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmolenskRpu::clear_has_freq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmolenskRpu::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline ::google::protobuf::int32 SmolenskRpu::freq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.SmolenskRpu.freq)
  return freq_;
}
inline void SmolenskRpu::set_freq(::google::protobuf::int32 value) {
  set_has_freq();
  freq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.SmolenskRpu.freq)
}

// -------------------------------------------------------------------

// ReceiverOptions

// required string title = 1;
inline bool ReceiverOptions::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverOptions::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverOptions::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverOptions::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ReceiverOptions::title() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ReceiverOptions.title)
  return *title_;
}
inline void ReceiverOptions::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.ReceiverOptions.title)
}
inline void ReceiverOptions::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.ReceiverOptions.title)
}
inline void ReceiverOptions::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.ReceiverOptions.title)
}
inline ::std::string* ReceiverOptions::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.ReceiverOptions.title)
  return title_;
}
inline ::std::string* ReceiverOptions::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReceiverOptions::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.ReceiverOptions.title)
}

// required bool status = 2;
inline bool ReceiverOptions::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverOptions::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverOptions::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverOptions::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool ReceiverOptions::status() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ReceiverOptions.status)
  return status_;
}
inline void ReceiverOptions::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.ReceiverOptions.status)
}

// required string ip = 3;
inline bool ReceiverOptions::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverOptions::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverOptions::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverOptions::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ReceiverOptions::ip() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ReceiverOptions.ip)
  return *ip_;
}
inline void ReceiverOptions::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.ReceiverOptions.ip)
}
inline void ReceiverOptions::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.ReceiverOptions.ip)
}
inline void ReceiverOptions::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.ReceiverOptions.ip)
}
inline ::std::string* ReceiverOptions::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.ReceiverOptions.ip)
  return ip_;
}
inline ::std::string* ReceiverOptions::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReceiverOptions::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.ReceiverOptions.ip)
}

// required int32 port = 4;
inline bool ReceiverOptions::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverOptions::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverOptions::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverOptions::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ReceiverOptions::port() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ReceiverOptions.port)
  return port_;
}
inline void ReceiverOptions::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.ReceiverOptions.port)
}

// required int32 type = 5;
inline bool ReceiverOptions::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverOptions::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverOptions::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverOptions::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ReceiverOptions::type() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ReceiverOptions.type)
  return type_;
}
inline void ReceiverOptions::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.ReceiverOptions.type)
}

// optional .RdsProtobuf.Prm300 settingsPrm300 = 6;
inline bool ReceiverOptions::has_settingsprm300() const {
  return ReceiverType_case() == kSettingsPrm300;
}
inline void ReceiverOptions::set_has_settingsprm300() {
  _oneof_case_[0] = kSettingsPrm300;
}
inline void ReceiverOptions::clear_settingsprm300() {
  if (has_settingsprm300()) {
    delete ReceiverType_.settingsprm300_;
    clear_has_ReceiverType();
  }
}
inline const ::RdsProtobuf::Prm300& ReceiverOptions::settingsprm300() const {
  return has_settingsprm300() ? *ReceiverType_.settingsprm300_
                      : ::RdsProtobuf::Prm300::default_instance();
}
inline ::RdsProtobuf::Prm300* ReceiverOptions::mutable_settingsprm300() {
  if (!has_settingsprm300()) {
    clear_ReceiverType();
    set_has_settingsprm300();
    ReceiverType_.settingsprm300_ = new ::RdsProtobuf::Prm300;
  }
  return ReceiverType_.settingsprm300_;
}
inline ::RdsProtobuf::Prm300* ReceiverOptions::release_settingsprm300() {
  if (has_settingsprm300()) {
    clear_has_ReceiverType();
    ::RdsProtobuf::Prm300* temp = ReceiverType_.settingsprm300_;
    ReceiverType_.settingsprm300_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReceiverOptions::set_allocated_settingsprm300(::RdsProtobuf::Prm300* settingsprm300) {
  clear_ReceiverType();
  if (settingsprm300) {
    set_has_settingsprm300();
    ReceiverType_.settingsprm300_ = settingsprm300;
  }
}

// optional .RdsProtobuf.SmolenskRpu settingsSmolenskRpu = 7;
inline bool ReceiverOptions::has_settingssmolenskrpu() const {
  return ReceiverType_case() == kSettingsSmolenskRpu;
}
inline void ReceiverOptions::set_has_settingssmolenskrpu() {
  _oneof_case_[0] = kSettingsSmolenskRpu;
}
inline void ReceiverOptions::clear_settingssmolenskrpu() {
  if (has_settingssmolenskrpu()) {
    delete ReceiverType_.settingssmolenskrpu_;
    clear_has_ReceiverType();
  }
}
inline const ::RdsProtobuf::SmolenskRpu& ReceiverOptions::settingssmolenskrpu() const {
  return has_settingssmolenskrpu() ? *ReceiverType_.settingssmolenskrpu_
                      : ::RdsProtobuf::SmolenskRpu::default_instance();
}
inline ::RdsProtobuf::SmolenskRpu* ReceiverOptions::mutable_settingssmolenskrpu() {
  if (!has_settingssmolenskrpu()) {
    clear_ReceiverType();
    set_has_settingssmolenskrpu();
    ReceiverType_.settingssmolenskrpu_ = new ::RdsProtobuf::SmolenskRpu;
  }
  return ReceiverType_.settingssmolenskrpu_;
}
inline ::RdsProtobuf::SmolenskRpu* ReceiverOptions::release_settingssmolenskrpu() {
  if (has_settingssmolenskrpu()) {
    clear_has_ReceiverType();
    ::RdsProtobuf::SmolenskRpu* temp = ReceiverType_.settingssmolenskrpu_;
    ReceiverType_.settingssmolenskrpu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReceiverOptions::set_allocated_settingssmolenskrpu(::RdsProtobuf::SmolenskRpu* settingssmolenskrpu) {
  clear_ReceiverType();
  if (settingssmolenskrpu) {
    set_has_settingssmolenskrpu();
    ReceiverType_.settingssmolenskrpu_ = settingssmolenskrpu;
  }
}

inline bool ReceiverOptions::has_ReceiverType() {
  return ReceiverType_case() != RECEIVERTYPE_NOT_SET;
}
inline void ReceiverOptions::clear_has_ReceiverType() {
  _oneof_case_[0] = RECEIVERTYPE_NOT_SET;
}
inline ReceiverOptions::ReceiverTypeCase ReceiverOptions::ReceiverType_case() const {
  return ReceiverOptions::ReceiverTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChannelOptions

// required string title = 1;
inline bool ChannelOptions::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelOptions::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelOptions::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelOptions::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ChannelOptions::title() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ChannelOptions.title)
  return *title_;
}
inline void ChannelOptions::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.ChannelOptions.title)
}
inline void ChannelOptions::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.ChannelOptions.title)
}
inline void ChannelOptions::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.ChannelOptions.title)
}
inline ::std::string* ChannelOptions::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.ChannelOptions.title)
  return title_;
}
inline ::std::string* ChannelOptions::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChannelOptions::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.ChannelOptions.title)
}

// required bool inversion = 2;
inline bool ChannelOptions::has_inversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChannelOptions::set_has_inversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChannelOptions::clear_has_inversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChannelOptions::clear_inversion() {
  inversion_ = false;
  clear_has_inversion();
}
inline bool ChannelOptions::inversion() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ChannelOptions.inversion)
  return inversion_;
}
inline void ChannelOptions::set_inversion(bool value) {
  set_has_inversion();
  inversion_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.ChannelOptions.inversion)
}

// required .RdsProtobuf.ReceiverOptions receiver = 3;
inline bool ChannelOptions::has_receiver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChannelOptions::set_has_receiver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChannelOptions::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChannelOptions::clear_receiver() {
  if (receiver_ != NULL) receiver_->::RdsProtobuf::ReceiverOptions::Clear();
  clear_has_receiver();
}
inline const ::RdsProtobuf::ReceiverOptions& ChannelOptions::receiver() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ChannelOptions.receiver)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return receiver_ != NULL ? *receiver_ : *default_instance().receiver_;
#else
  return receiver_ != NULL ? *receiver_ : *default_instance_->receiver_;
#endif
}
inline ::RdsProtobuf::ReceiverOptions* ChannelOptions::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == NULL) receiver_ = new ::RdsProtobuf::ReceiverOptions;
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.ChannelOptions.receiver)
  return receiver_;
}
inline ::RdsProtobuf::ReceiverOptions* ChannelOptions::release_receiver() {
  clear_has_receiver();
  ::RdsProtobuf::ReceiverOptions* temp = receiver_;
  receiver_ = NULL;
  return temp;
}
inline void ChannelOptions::set_allocated_receiver(::RdsProtobuf::ReceiverOptions* receiver) {
  delete receiver_;
  receiver_ = receiver;
  if (receiver) {
    set_has_receiver();
  } else {
    clear_has_receiver();
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.ChannelOptions.receiver)
}

// -------------------------------------------------------------------

// DeviceOptions

// required string title = 1;
inline bool DeviceOptions::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceOptions::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceOptions::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceOptions::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& DeviceOptions::title() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.title)
  return *title_;
}
inline void DeviceOptions::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.title)
}
inline void DeviceOptions::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.DeviceOptions.title)
}
inline void DeviceOptions::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.DeviceOptions.title)
}
inline ::std::string* DeviceOptions::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.DeviceOptions.title)
  return title_;
}
inline ::std::string* DeviceOptions::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceOptions::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.DeviceOptions.title)
}

// required bool status = 2;
inline bool DeviceOptions::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceOptions::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceOptions::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceOptions::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool DeviceOptions::status() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.status)
  return status_;
}
inline void DeviceOptions::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.status)
}

// required string ip = 3;
inline bool DeviceOptions::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceOptions::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceOptions::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceOptions::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& DeviceOptions::ip() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.ip)
  return *ip_;
}
inline void DeviceOptions::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.ip)
}
inline void DeviceOptions::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.DeviceOptions.ip)
}
inline void DeviceOptions::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.DeviceOptions.ip)
}
inline ::std::string* DeviceOptions::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.DeviceOptions.ip)
  return ip_;
}
inline ::std::string* DeviceOptions::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceOptions::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.DeviceOptions.ip)
}

// required int32 portSCTP = 4;
inline bool DeviceOptions::has_portsctp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceOptions::set_has_portsctp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceOptions::clear_has_portsctp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceOptions::clear_portsctp() {
  portsctp_ = 0;
  clear_has_portsctp();
}
inline ::google::protobuf::int32 DeviceOptions::portsctp() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.portSCTP)
  return portsctp_;
}
inline void DeviceOptions::set_portsctp(::google::protobuf::int32 value) {
  set_has_portsctp();
  portsctp_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.portSCTP)
}

// required int32 portHTTP = 5;
inline bool DeviceOptions::has_porthttp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceOptions::set_has_porthttp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceOptions::clear_has_porthttp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceOptions::clear_porthttp() {
  porthttp_ = 0;
  clear_has_porthttp();
}
inline ::google::protobuf::int32 DeviceOptions::porthttp() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.portHTTP)
  return porthttp_;
}
inline void DeviceOptions::set_porthttp(::google::protobuf::int32 value) {
  set_has_porthttp();
  porthttp_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.portHTTP)
}

// required int32 channelsNum = 6;
inline bool DeviceOptions::has_channelsnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceOptions::set_has_channelsnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceOptions::clear_has_channelsnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceOptions::clear_channelsnum() {
  channelsnum_ = 0;
  clear_has_channelsnum();
}
inline ::google::protobuf::int32 DeviceOptions::channelsnum() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.channelsNum)
  return channelsnum_;
}
inline void DeviceOptions::set_channelsnum(::google::protobuf::int32 value) {
  set_has_channelsnum();
  channelsnum_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.channelsNum)
}

// required int32 sync = 7;
inline bool DeviceOptions::has_sync() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceOptions::set_has_sync() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceOptions::clear_has_sync() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceOptions::clear_sync() {
  sync_ = 0;
  clear_has_sync();
}
inline ::google::protobuf::int32 DeviceOptions::sync() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.sync)
  return sync_;
}
inline void DeviceOptions::set_sync(::google::protobuf::int32 value) {
  set_has_sync();
  sync_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.sync)
}

// required int32 board = 8;
inline bool DeviceOptions::has_board() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceOptions::set_has_board() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceOptions::clear_has_board() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceOptions::clear_board() {
  board_ = 0;
  clear_has_board();
}
inline ::google::protobuf::int32 DeviceOptions::board() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.board)
  return board_;
}
inline void DeviceOptions::set_board(::google::protobuf::int32 value) {
  set_has_board();
  board_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DeviceOptions.board)
}

// repeated .RdsProtobuf.ChannelOptions channels = 9;
inline int DeviceOptions::channels_size() const {
  return channels_.size();
}
inline void DeviceOptions::clear_channels() {
  channels_.Clear();
}
inline const ::RdsProtobuf::ChannelOptions& DeviceOptions::channels(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DeviceOptions.channels)
  return channels_.Get(index);
}
inline ::RdsProtobuf::ChannelOptions* DeviceOptions::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.DeviceOptions.channels)
  return channels_.Mutable(index);
}
inline ::RdsProtobuf::ChannelOptions* DeviceOptions::add_channels() {
  // @@protoc_insertion_point(field_add:RdsProtobuf.DeviceOptions.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ChannelOptions >&
DeviceOptions::channels() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.DeviceOptions.channels)
  return channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ChannelOptions >*
DeviceOptions::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.DeviceOptions.channels)
  return &channels_;
}

// -------------------------------------------------------------------

// TimeFreqArea

// required float time_start = 1;
inline bool TimeFreqArea::has_time_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeFreqArea::set_has_time_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeFreqArea::clear_has_time_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeFreqArea::clear_time_start() {
  time_start_ = 0;
  clear_has_time_start();
}
inline float TimeFreqArea::time_start() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.TimeFreqArea.time_start)
  return time_start_;
}
inline void TimeFreqArea::set_time_start(float value) {
  set_has_time_start();
  time_start_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.TimeFreqArea.time_start)
}

// required float time_end = 2;
inline bool TimeFreqArea::has_time_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeFreqArea::set_has_time_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeFreqArea::clear_has_time_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeFreqArea::clear_time_end() {
  time_end_ = 0;
  clear_has_time_end();
}
inline float TimeFreqArea::time_end() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.TimeFreqArea.time_end)
  return time_end_;
}
inline void TimeFreqArea::set_time_end(float value) {
  set_has_time_end();
  time_end_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.TimeFreqArea.time_end)
}

// required float freq_start = 3;
inline bool TimeFreqArea::has_freq_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeFreqArea::set_has_freq_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeFreqArea::clear_has_freq_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeFreqArea::clear_freq_start() {
  freq_start_ = 0;
  clear_has_freq_start();
}
inline float TimeFreqArea::freq_start() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.TimeFreqArea.freq_start)
  return freq_start_;
}
inline void TimeFreqArea::set_freq_start(float value) {
  set_has_freq_start();
  freq_start_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.TimeFreqArea.freq_start)
}

// required float freq_end = 4;
inline bool TimeFreqArea::has_freq_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeFreqArea::set_has_freq_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeFreqArea::clear_has_freq_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeFreqArea::clear_freq_end() {
  freq_end_ = 0;
  clear_has_freq_end();
}
inline float TimeFreqArea::freq_end() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.TimeFreqArea.freq_end)
  return freq_end_;
}
inline void TimeFreqArea::set_freq_end(float value) {
  set_has_freq_end();
  freq_end_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.TimeFreqArea.freq_end)
}

// -------------------------------------------------------------------

// Mode

// optional int32 index = 1;
inline bool Mode::has_index() const {
  return Message_case() == kIndex;
}
inline void Mode::set_has_index() {
  _oneof_case_[0] = kIndex;
}
inline void Mode::clear_index() {
  if (has_index()) {
    Message_.index_ = 0;
    clear_has_Message();
  }
}
inline ::google::protobuf::int32 Mode::index() const {
  if (has_index()) {
    return Message_.index_;
  }
  return 0;
}
inline void Mode::set_index(::google::protobuf::int32 value) {
  if (!has_index()) {
    clear_Message();
    set_has_index();
  }
  Message_.index_ = value;
}

// optional bool status = 2;
inline bool Mode::has_status() const {
  return Message_case() == kStatus;
}
inline void Mode::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Mode::clear_status() {
  if (has_status()) {
    Message_.status_ = false;
    clear_has_Message();
  }
}
inline bool Mode::status() const {
  if (has_status()) {
    return Message_.status_;
  }
  return false;
}
inline void Mode::set_status(bool value) {
  if (!has_status()) {
    clear_Message();
    set_has_status();
  }
  Message_.status_ = value;
}

inline bool Mode::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void Mode::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Mode::MessageCase Mode::Message_case() const {
  return Mode::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// System_SystemOptions

// required string title = 1;
inline bool System_SystemOptions::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void System_SystemOptions::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void System_SystemOptions::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void System_SystemOptions::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& System_SystemOptions::title() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.SystemOptions.title)
  return *title_;
}
inline void System_SystemOptions::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.SystemOptions.title)
}
inline void System_SystemOptions::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.System.SystemOptions.title)
}
inline void System_SystemOptions::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.System.SystemOptions.title)
}
inline ::std::string* System_SystemOptions::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.System.SystemOptions.title)
  return title_;
}
inline ::std::string* System_SystemOptions::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void System_SystemOptions::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.System.SystemOptions.title)
}

// required int32 devices_Num = 2;
inline bool System_SystemOptions::has_devices_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void System_SystemOptions::set_has_devices_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void System_SystemOptions::clear_has_devices_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void System_SystemOptions::clear_devices_num() {
  devices_num_ = 0;
  clear_has_devices_num();
}
inline ::google::protobuf::int32 System_SystemOptions::devices_num() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.SystemOptions.devices_Num)
  return devices_num_;
}
inline void System_SystemOptions::set_devices_num(::google::protobuf::int32 value) {
  set_has_devices_num();
  devices_num_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.SystemOptions.devices_Num)
}

// repeated .RdsProtobuf.DeviceOptions devices = 3;
inline int System_SystemOptions::devices_size() const {
  return devices_.size();
}
inline void System_SystemOptions::clear_devices() {
  devices_.Clear();
}
inline const ::RdsProtobuf::DeviceOptions& System_SystemOptions::devices(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.SystemOptions.devices)
  return devices_.Get(index);
}
inline ::RdsProtobuf::DeviceOptions* System_SystemOptions::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.System.SystemOptions.devices)
  return devices_.Mutable(index);
}
inline ::RdsProtobuf::DeviceOptions* System_SystemOptions::add_devices() {
  // @@protoc_insertion_point(field_add:RdsProtobuf.System.SystemOptions.devices)
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::DeviceOptions >&
System_SystemOptions::devices() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.System.SystemOptions.devices)
  return devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::DeviceOptions >*
System_SystemOptions::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.System.SystemOptions.devices)
  return &devices_;
}

// required int32 separate_Receivers_Num = 4;
inline bool System_SystemOptions::has_separate_receivers_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void System_SystemOptions::set_has_separate_receivers_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void System_SystemOptions::clear_has_separate_receivers_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void System_SystemOptions::clear_separate_receivers_num() {
  separate_receivers_num_ = 0;
  clear_has_separate_receivers_num();
}
inline ::google::protobuf::int32 System_SystemOptions::separate_receivers_num() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.SystemOptions.separate_Receivers_Num)
  return separate_receivers_num_;
}
inline void System_SystemOptions::set_separate_receivers_num(::google::protobuf::int32 value) {
  set_has_separate_receivers_num();
  separate_receivers_num_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.SystemOptions.separate_Receivers_Num)
}

// repeated .RdsProtobuf.ReceiverOptions separate_Receivers = 5;
inline int System_SystemOptions::separate_receivers_size() const {
  return separate_receivers_.size();
}
inline void System_SystemOptions::clear_separate_receivers() {
  separate_receivers_.Clear();
}
inline const ::RdsProtobuf::ReceiverOptions& System_SystemOptions::separate_receivers(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.SystemOptions.separate_Receivers)
  return separate_receivers_.Get(index);
}
inline ::RdsProtobuf::ReceiverOptions* System_SystemOptions::mutable_separate_receivers(int index) {
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.System.SystemOptions.separate_Receivers)
  return separate_receivers_.Mutable(index);
}
inline ::RdsProtobuf::ReceiverOptions* System_SystemOptions::add_separate_receivers() {
  // @@protoc_insertion_point(field_add:RdsProtobuf.System.SystemOptions.separate_Receivers)
  return separate_receivers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ReceiverOptions >&
System_SystemOptions::separate_receivers() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.System.SystemOptions.separate_Receivers)
  return separate_receivers_;
}
inline ::google::protobuf::RepeatedPtrField< ::RdsProtobuf::ReceiverOptions >*
System_SystemOptions::mutable_separate_receivers() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.System.SystemOptions.separate_Receivers)
  return &separate_receivers_;
}

// -------------------------------------------------------------------

// System_Device

// required int32 device_Index = 1;
inline bool System_Device::has_device_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void System_Device::set_has_device_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void System_Device::clear_has_device_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void System_Device::clear_device_index() {
  device_index_ = 0;
  clear_has_device_index();
}
inline ::google::protobuf::int32 System_Device::device_index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.Device.device_Index)
  return device_index_;
}
inline void System_Device::set_device_index(::google::protobuf::int32 value) {
  set_has_device_index();
  device_index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.Device.device_Index)
}

// required bool status = 2;
inline bool System_Device::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void System_Device::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void System_Device::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void System_Device::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool System_Device::status() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.Device.status)
  return status_;
}
inline void System_Device::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.Device.status)
}

// -------------------------------------------------------------------

// System_Receiver

// required int32 device_Index = 1;
inline bool System_Receiver::has_device_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void System_Receiver::set_has_device_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void System_Receiver::clear_has_device_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void System_Receiver::clear_device_index() {
  device_index_ = 0;
  clear_has_device_index();
}
inline ::google::protobuf::int32 System_Receiver::device_index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.Receiver.device_Index)
  return device_index_;
}
inline void System_Receiver::set_device_index(::google::protobuf::int32 value) {
  set_has_device_index();
  device_index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.Receiver.device_Index)
}

// required int32 channel_Index = 2;
inline bool System_Receiver::has_channel_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void System_Receiver::set_has_channel_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void System_Receiver::clear_has_channel_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void System_Receiver::clear_channel_index() {
  channel_index_ = 0;
  clear_has_channel_index();
}
inline ::google::protobuf::int32 System_Receiver::channel_index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.Receiver.channel_Index)
  return channel_index_;
}
inline void System_Receiver::set_channel_index(::google::protobuf::int32 value) {
  set_has_channel_index();
  channel_index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.Receiver.channel_Index)
}

// optional bool status = 3;
inline bool System_Receiver::has_status() const {
  return messageType_case() == kStatus;
}
inline void System_Receiver::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void System_Receiver::clear_status() {
  if (has_status()) {
    messageType_.status_ = false;
    clear_has_messageType();
  }
}
inline bool System_Receiver::status() const {
  if (has_status()) {
    return messageType_.status_;
  }
  return false;
}
inline void System_Receiver::set_status(bool value) {
  if (!has_status()) {
    clear_messageType();
    set_has_status();
  }
  messageType_.status_ = value;
}

// optional .RdsProtobuf.Prm300 settingsPrm300 = 4;
inline bool System_Receiver::has_settingsprm300() const {
  return messageType_case() == kSettingsPrm300;
}
inline void System_Receiver::set_has_settingsprm300() {
  _oneof_case_[0] = kSettingsPrm300;
}
inline void System_Receiver::clear_settingsprm300() {
  if (has_settingsprm300()) {
    delete messageType_.settingsprm300_;
    clear_has_messageType();
  }
}
inline const ::RdsProtobuf::Prm300& System_Receiver::settingsprm300() const {
  return has_settingsprm300() ? *messageType_.settingsprm300_
                      : ::RdsProtobuf::Prm300::default_instance();
}
inline ::RdsProtobuf::Prm300* System_Receiver::mutable_settingsprm300() {
  if (!has_settingsprm300()) {
    clear_messageType();
    set_has_settingsprm300();
    messageType_.settingsprm300_ = new ::RdsProtobuf::Prm300;
  }
  return messageType_.settingsprm300_;
}
inline ::RdsProtobuf::Prm300* System_Receiver::release_settingsprm300() {
  if (has_settingsprm300()) {
    clear_has_messageType();
    ::RdsProtobuf::Prm300* temp = messageType_.settingsprm300_;
    messageType_.settingsprm300_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System_Receiver::set_allocated_settingsprm300(::RdsProtobuf::Prm300* settingsprm300) {
  clear_messageType();
  if (settingsprm300) {
    set_has_settingsprm300();
    messageType_.settingsprm300_ = settingsprm300;
  }
}

// optional .RdsProtobuf.SmolenskRpu settingsSmolenskRpu = 5;
inline bool System_Receiver::has_settingssmolenskrpu() const {
  return messageType_case() == kSettingsSmolenskRpu;
}
inline void System_Receiver::set_has_settingssmolenskrpu() {
  _oneof_case_[0] = kSettingsSmolenskRpu;
}
inline void System_Receiver::clear_settingssmolenskrpu() {
  if (has_settingssmolenskrpu()) {
    delete messageType_.settingssmolenskrpu_;
    clear_has_messageType();
  }
}
inline const ::RdsProtobuf::SmolenskRpu& System_Receiver::settingssmolenskrpu() const {
  return has_settingssmolenskrpu() ? *messageType_.settingssmolenskrpu_
                      : ::RdsProtobuf::SmolenskRpu::default_instance();
}
inline ::RdsProtobuf::SmolenskRpu* System_Receiver::mutable_settingssmolenskrpu() {
  if (!has_settingssmolenskrpu()) {
    clear_messageType();
    set_has_settingssmolenskrpu();
    messageType_.settingssmolenskrpu_ = new ::RdsProtobuf::SmolenskRpu;
  }
  return messageType_.settingssmolenskrpu_;
}
inline ::RdsProtobuf::SmolenskRpu* System_Receiver::release_settingssmolenskrpu() {
  if (has_settingssmolenskrpu()) {
    clear_has_messageType();
    ::RdsProtobuf::SmolenskRpu* temp = messageType_.settingssmolenskrpu_;
    messageType_.settingssmolenskrpu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System_Receiver::set_allocated_settingssmolenskrpu(::RdsProtobuf::SmolenskRpu* settingssmolenskrpu) {
  clear_messageType();
  if (settingssmolenskrpu) {
    set_has_settingssmolenskrpu();
    messageType_.settingssmolenskrpu_ = settingssmolenskrpu;
  }
}

inline bool System_Receiver::has_messageType() {
  return messageType_case() != MESSAGETYPE_NOT_SET;
}
inline void System_Receiver::clear_has_messageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline System_Receiver::MessageTypeCase System_Receiver::messageType_case() const {
  return System_Receiver::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// System_SeparateReceiver

// required int32 receiver_Index = 1;
inline bool System_SeparateReceiver::has_receiver_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void System_SeparateReceiver::set_has_receiver_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void System_SeparateReceiver::clear_has_receiver_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void System_SeparateReceiver::clear_receiver_index() {
  receiver_index_ = 0;
  clear_has_receiver_index();
}
inline ::google::protobuf::int32 System_SeparateReceiver::receiver_index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.System.SeparateReceiver.receiver_Index)
  return receiver_index_;
}
inline void System_SeparateReceiver::set_receiver_index(::google::protobuf::int32 value) {
  set_has_receiver_index();
  receiver_index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.System.SeparateReceiver.receiver_Index)
}

// optional bool status = 2;
inline bool System_SeparateReceiver::has_status() const {
  return messageType_case() == kStatus;
}
inline void System_SeparateReceiver::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void System_SeparateReceiver::clear_status() {
  if (has_status()) {
    messageType_.status_ = false;
    clear_has_messageType();
  }
}
inline bool System_SeparateReceiver::status() const {
  if (has_status()) {
    return messageType_.status_;
  }
  return false;
}
inline void System_SeparateReceiver::set_status(bool value) {
  if (!has_status()) {
    clear_messageType();
    set_has_status();
  }
  messageType_.status_ = value;
}

// optional .RdsProtobuf.Prm300 settingsPrm300 = 4;
inline bool System_SeparateReceiver::has_settingsprm300() const {
  return messageType_case() == kSettingsPrm300;
}
inline void System_SeparateReceiver::set_has_settingsprm300() {
  _oneof_case_[0] = kSettingsPrm300;
}
inline void System_SeparateReceiver::clear_settingsprm300() {
  if (has_settingsprm300()) {
    delete messageType_.settingsprm300_;
    clear_has_messageType();
  }
}
inline const ::RdsProtobuf::Prm300& System_SeparateReceiver::settingsprm300() const {
  return has_settingsprm300() ? *messageType_.settingsprm300_
                      : ::RdsProtobuf::Prm300::default_instance();
}
inline ::RdsProtobuf::Prm300* System_SeparateReceiver::mutable_settingsprm300() {
  if (!has_settingsprm300()) {
    clear_messageType();
    set_has_settingsprm300();
    messageType_.settingsprm300_ = new ::RdsProtobuf::Prm300;
  }
  return messageType_.settingsprm300_;
}
inline ::RdsProtobuf::Prm300* System_SeparateReceiver::release_settingsprm300() {
  if (has_settingsprm300()) {
    clear_has_messageType();
    ::RdsProtobuf::Prm300* temp = messageType_.settingsprm300_;
    messageType_.settingsprm300_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System_SeparateReceiver::set_allocated_settingsprm300(::RdsProtobuf::Prm300* settingsprm300) {
  clear_messageType();
  if (settingsprm300) {
    set_has_settingsprm300();
    messageType_.settingsprm300_ = settingsprm300;
  }
}

// optional .RdsProtobuf.SmolenskRpu settingsSmolenskRpu = 5;
inline bool System_SeparateReceiver::has_settingssmolenskrpu() const {
  return messageType_case() == kSettingsSmolenskRpu;
}
inline void System_SeparateReceiver::set_has_settingssmolenskrpu() {
  _oneof_case_[0] = kSettingsSmolenskRpu;
}
inline void System_SeparateReceiver::clear_settingssmolenskrpu() {
  if (has_settingssmolenskrpu()) {
    delete messageType_.settingssmolenskrpu_;
    clear_has_messageType();
  }
}
inline const ::RdsProtobuf::SmolenskRpu& System_SeparateReceiver::settingssmolenskrpu() const {
  return has_settingssmolenskrpu() ? *messageType_.settingssmolenskrpu_
                      : ::RdsProtobuf::SmolenskRpu::default_instance();
}
inline ::RdsProtobuf::SmolenskRpu* System_SeparateReceiver::mutable_settingssmolenskrpu() {
  if (!has_settingssmolenskrpu()) {
    clear_messageType();
    set_has_settingssmolenskrpu();
    messageType_.settingssmolenskrpu_ = new ::RdsProtobuf::SmolenskRpu;
  }
  return messageType_.settingssmolenskrpu_;
}
inline ::RdsProtobuf::SmolenskRpu* System_SeparateReceiver::release_settingssmolenskrpu() {
  if (has_settingssmolenskrpu()) {
    clear_has_messageType();
    ::RdsProtobuf::SmolenskRpu* temp = messageType_.settingssmolenskrpu_;
    messageType_.settingssmolenskrpu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System_SeparateReceiver::set_allocated_settingssmolenskrpu(::RdsProtobuf::SmolenskRpu* settingssmolenskrpu) {
  clear_messageType();
  if (settingssmolenskrpu) {
    set_has_settingssmolenskrpu();
    messageType_.settingssmolenskrpu_ = settingssmolenskrpu;
  }
}

inline bool System_SeparateReceiver::has_messageType() {
  return messageType_case() != MESSAGETYPE_NOT_SET;
}
inline void System_SeparateReceiver::clear_has_messageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline System_SeparateReceiver::MessageTypeCase System_SeparateReceiver::messageType_case() const {
  return System_SeparateReceiver::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// System

// optional .RdsProtobuf.System.SystemOptions options = 1;
inline bool System::has_options() const {
  return Message_case() == kOptions;
}
inline void System::set_has_options() {
  _oneof_case_[0] = kOptions;
}
inline void System::clear_options() {
  if (has_options()) {
    delete Message_.options_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::System_SystemOptions& System::options() const {
  return has_options() ? *Message_.options_
                      : ::RdsProtobuf::System_SystemOptions::default_instance();
}
inline ::RdsProtobuf::System_SystemOptions* System::mutable_options() {
  if (!has_options()) {
    clear_Message();
    set_has_options();
    Message_.options_ = new ::RdsProtobuf::System_SystemOptions;
  }
  return Message_.options_;
}
inline ::RdsProtobuf::System_SystemOptions* System::release_options() {
  if (has_options()) {
    clear_has_Message();
    ::RdsProtobuf::System_SystemOptions* temp = Message_.options_;
    Message_.options_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System::set_allocated_options(::RdsProtobuf::System_SystemOptions* options) {
  clear_Message();
  if (options) {
    set_has_options();
    Message_.options_ = options;
  }
}

// optional .RdsProtobuf.System.Device device = 2;
inline bool System::has_device() const {
  return Message_case() == kDevice;
}
inline void System::set_has_device() {
  _oneof_case_[0] = kDevice;
}
inline void System::clear_device() {
  if (has_device()) {
    delete Message_.device_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::System_Device& System::device() const {
  return has_device() ? *Message_.device_
                      : ::RdsProtobuf::System_Device::default_instance();
}
inline ::RdsProtobuf::System_Device* System::mutable_device() {
  if (!has_device()) {
    clear_Message();
    set_has_device();
    Message_.device_ = new ::RdsProtobuf::System_Device;
  }
  return Message_.device_;
}
inline ::RdsProtobuf::System_Device* System::release_device() {
  if (has_device()) {
    clear_has_Message();
    ::RdsProtobuf::System_Device* temp = Message_.device_;
    Message_.device_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System::set_allocated_device(::RdsProtobuf::System_Device* device) {
  clear_Message();
  if (device) {
    set_has_device();
    Message_.device_ = device;
  }
}

// optional .RdsProtobuf.System.Receiver receiver = 3;
inline bool System::has_receiver() const {
  return Message_case() == kReceiver;
}
inline void System::set_has_receiver() {
  _oneof_case_[0] = kReceiver;
}
inline void System::clear_receiver() {
  if (has_receiver()) {
    delete Message_.receiver_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::System_Receiver& System::receiver() const {
  return has_receiver() ? *Message_.receiver_
                      : ::RdsProtobuf::System_Receiver::default_instance();
}
inline ::RdsProtobuf::System_Receiver* System::mutable_receiver() {
  if (!has_receiver()) {
    clear_Message();
    set_has_receiver();
    Message_.receiver_ = new ::RdsProtobuf::System_Receiver;
  }
  return Message_.receiver_;
}
inline ::RdsProtobuf::System_Receiver* System::release_receiver() {
  if (has_receiver()) {
    clear_has_Message();
    ::RdsProtobuf::System_Receiver* temp = Message_.receiver_;
    Message_.receiver_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System::set_allocated_receiver(::RdsProtobuf::System_Receiver* receiver) {
  clear_Message();
  if (receiver) {
    set_has_receiver();
    Message_.receiver_ = receiver;
  }
}

// optional .RdsProtobuf.System.SeparateReceiver separate_Receiver = 4;
inline bool System::has_separate_receiver() const {
  return Message_case() == kSeparateReceiver;
}
inline void System::set_has_separate_receiver() {
  _oneof_case_[0] = kSeparateReceiver;
}
inline void System::clear_separate_receiver() {
  if (has_separate_receiver()) {
    delete Message_.separate_receiver_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::System_SeparateReceiver& System::separate_receiver() const {
  return has_separate_receiver() ? *Message_.separate_receiver_
                      : ::RdsProtobuf::System_SeparateReceiver::default_instance();
}
inline ::RdsProtobuf::System_SeparateReceiver* System::mutable_separate_receiver() {
  if (!has_separate_receiver()) {
    clear_Message();
    set_has_separate_receiver();
    Message_.separate_receiver_ = new ::RdsProtobuf::System_SeparateReceiver;
  }
  return Message_.separate_receiver_;
}
inline ::RdsProtobuf::System_SeparateReceiver* System::release_separate_receiver() {
  if (has_separate_receiver()) {
    clear_has_Message();
    ::RdsProtobuf::System_SeparateReceiver* temp = Message_.separate_receiver_;
    Message_.separate_receiver_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void System::set_allocated_separate_receiver(::RdsProtobuf::System_SeparateReceiver* separate_receiver) {
  clear_Message();
  if (separate_receiver) {
    set_has_separate_receiver();
    Message_.separate_receiver_ = separate_receiver;
  }
}

inline bool System::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void System::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline System::MessageCase System::Message_case() const {
  return System::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Location_LocationOptions

// required int32 chanNum = 1;
inline bool Location_LocationOptions::has_channum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location_LocationOptions::set_has_channum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location_LocationOptions::clear_has_channum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location_LocationOptions::clear_channum() {
  channum_ = 0;
  clear_has_channum();
}
inline ::google::protobuf::int32 Location_LocationOptions::channum() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.chanNum)
  return channum_;
}
inline void Location_LocationOptions::set_channum(::google::protobuf::int32 value) {
  set_has_channum();
  channum_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.chanNum)
}

// required int32 mode = 2;
inline bool Location_LocationOptions::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location_LocationOptions::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location_LocationOptions::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location_LocationOptions::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 Location_LocationOptions::mode() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.mode)
  return mode_;
}
inline void Location_LocationOptions::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.mode)
}

// required int32 baseIndex = 3;
inline bool Location_LocationOptions::has_baseindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location_LocationOptions::set_has_baseindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location_LocationOptions::clear_has_baseindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location_LocationOptions::clear_baseindex() {
  baseindex_ = 0;
  clear_has_baseindex();
}
inline ::google::protobuf::int32 Location_LocationOptions::baseindex() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.baseIndex)
  return baseindex_;
}
inline void Location_LocationOptions::set_baseindex(::google::protobuf::int32 value) {
  set_has_baseindex();
  baseindex_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.baseIndex)
}

// required bool convolution = 4;
inline bool Location_LocationOptions::has_convolution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location_LocationOptions::set_has_convolution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location_LocationOptions::clear_has_convolution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location_LocationOptions::clear_convolution() {
  convolution_ = false;
  clear_has_convolution();
}
inline bool Location_LocationOptions::convolution() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.convolution)
  return convolution_;
}
inline void Location_LocationOptions::set_convolution(bool value) {
  set_has_convolution();
  convolution_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.convolution)
}

// required int32 spectrumMean = 5;
inline bool Location_LocationOptions::has_spectrummean() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location_LocationOptions::set_has_spectrummean() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location_LocationOptions::clear_has_spectrummean() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location_LocationOptions::clear_spectrummean() {
  spectrummean_ = 0;
  clear_has_spectrummean();
}
inline ::google::protobuf::int32 Location_LocationOptions::spectrummean() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.spectrumMean)
  return spectrummean_;
}
inline void Location_LocationOptions::set_spectrummean(::google::protobuf::int32 value) {
  set_has_spectrummean();
  spectrummean_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.spectrumMean)
}

// required int32 tuningMode = 6;
inline bool Location_LocationOptions::has_tuningmode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Location_LocationOptions::set_has_tuningmode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Location_LocationOptions::clear_has_tuningmode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Location_LocationOptions::clear_tuningmode() {
  tuningmode_ = 0;
  clear_has_tuningmode();
}
inline ::google::protobuf::int32 Location_LocationOptions::tuningmode() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.tuningMode)
  return tuningmode_;
}
inline void Location_LocationOptions::set_tuningmode(::google::protobuf::int32 value) {
  set_has_tuningmode();
  tuningmode_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.tuningMode)
}

// required int32 duration = 7;
inline bool Location_LocationOptions::has_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Location_LocationOptions::set_has_duration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Location_LocationOptions::clear_has_duration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Location_LocationOptions::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 Location_LocationOptions::duration() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.duration)
  return duration_;
}
inline void Location_LocationOptions::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.duration)
}

// required int32 centralFreq = 8;
inline bool Location_LocationOptions::has_centralfreq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Location_LocationOptions::set_has_centralfreq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Location_LocationOptions::clear_has_centralfreq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Location_LocationOptions::clear_centralfreq() {
  centralfreq_ = 0;
  clear_has_centralfreq();
}
inline ::google::protobuf::int32 Location_LocationOptions::centralfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.LocationOptions.centralFreq)
  return centralfreq_;
}
inline void Location_LocationOptions::set_centralfreq(::google::protobuf::int32 value) {
  set_has_centralfreq();
  centralfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.LocationOptions.centralFreq)
}

// -------------------------------------------------------------------

// Location_FilterOptions

// required int32 range = 1;
inline bool Location_FilterOptions::has_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location_FilterOptions::set_has_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location_FilterOptions::clear_has_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location_FilterOptions::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline ::google::protobuf::int32 Location_FilterOptions::range() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.FilterOptions.range)
  return range_;
}
inline void Location_FilterOptions::set_range(::google::protobuf::int32 value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.FilterOptions.range)
}

// required int32 shift = 2;
inline bool Location_FilterOptions::has_shift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location_FilterOptions::set_has_shift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location_FilterOptions::clear_has_shift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location_FilterOptions::clear_shift() {
  shift_ = 0;
  clear_has_shift();
}
inline ::google::protobuf::int32 Location_FilterOptions::shift() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Location.FilterOptions.shift)
  return shift_;
}
inline void Location_FilterOptions::set_shift(::google::protobuf::int32 value) {
  set_has_shift();
  shift_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Location.FilterOptions.shift)
}

// -------------------------------------------------------------------

// Location

// optional .RdsProtobuf.Location.LocationOptions options = 1;
inline bool Location::has_options() const {
  return Message_case() == kOptions;
}
inline void Location::set_has_options() {
  _oneof_case_[0] = kOptions;
}
inline void Location::clear_options() {
  if (has_options()) {
    delete Message_.options_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Location_LocationOptions& Location::options() const {
  return has_options() ? *Message_.options_
                      : ::RdsProtobuf::Location_LocationOptions::default_instance();
}
inline ::RdsProtobuf::Location_LocationOptions* Location::mutable_options() {
  if (!has_options()) {
    clear_Message();
    set_has_options();
    Message_.options_ = new ::RdsProtobuf::Location_LocationOptions;
  }
  return Message_.options_;
}
inline ::RdsProtobuf::Location_LocationOptions* Location::release_options() {
  if (has_options()) {
    clear_has_Message();
    ::RdsProtobuf::Location_LocationOptions* temp = Message_.options_;
    Message_.options_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Location::set_allocated_options(::RdsProtobuf::Location_LocationOptions* options) {
  clear_Message();
  if (options) {
    set_has_options();
    Message_.options_ = options;
  }
}

// optional .RdsProtobuf.Location.FilterOptions filter = 2;
inline bool Location::has_filter() const {
  return Message_case() == kFilter;
}
inline void Location::set_has_filter() {
  _oneof_case_[0] = kFilter;
}
inline void Location::clear_filter() {
  if (has_filter()) {
    delete Message_.filter_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Location_FilterOptions& Location::filter() const {
  return has_filter() ? *Message_.filter_
                      : ::RdsProtobuf::Location_FilterOptions::default_instance();
}
inline ::RdsProtobuf::Location_FilterOptions* Location::mutable_filter() {
  if (!has_filter()) {
    clear_Message();
    set_has_filter();
    Message_.filter_ = new ::RdsProtobuf::Location_FilterOptions;
  }
  return Message_.filter_;
}
inline ::RdsProtobuf::Location_FilterOptions* Location::release_filter() {
  if (has_filter()) {
    clear_has_Message();
    ::RdsProtobuf::Location_FilterOptions* temp = Message_.filter_;
    Message_.filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Location::set_allocated_filter(::RdsProtobuf::Location_FilterOptions* filter) {
  clear_Message();
  if (filter) {
    set_has_filter();
    Message_.filter_ = filter;
  }
}

inline bool Location::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void Location::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Location::MessageCase Location::Message_case() const {
  return Location::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Detector_DetectorOptions

// required int32 chanNum = 1;
inline bool Detector_DetectorOptions::has_channum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detector_DetectorOptions::set_has_channum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detector_DetectorOptions::clear_has_channum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detector_DetectorOptions::clear_channum() {
  channum_ = 0;
  clear_has_channum();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::channum() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.chanNum)
  return channum_;
}
inline void Detector_DetectorOptions::set_channum(::google::protobuf::int32 value) {
  set_has_channum();
  channum_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.chanNum)
}

// required int32 duration = 2;
inline bool Detector_DetectorOptions::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detector_DetectorOptions::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detector_DetectorOptions::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detector_DetectorOptions::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::duration() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.duration)
  return duration_;
}
inline void Detector_DetectorOptions::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.duration)
}

// required int32 startScanFreq = 3;
inline bool Detector_DetectorOptions::has_startscanfreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detector_DetectorOptions::set_has_startscanfreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detector_DetectorOptions::clear_has_startscanfreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detector_DetectorOptions::clear_startscanfreq() {
  startscanfreq_ = 0;
  clear_has_startscanfreq();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::startscanfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.startScanFreq)
  return startscanfreq_;
}
inline void Detector_DetectorOptions::set_startscanfreq(::google::protobuf::int32 value) {
  set_has_startscanfreq();
  startscanfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.startScanFreq)
}

// required int32 endScanFreq = 4;
inline bool Detector_DetectorOptions::has_endscanfreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Detector_DetectorOptions::set_has_endscanfreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Detector_DetectorOptions::clear_has_endscanfreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Detector_DetectorOptions::clear_endscanfreq() {
  endscanfreq_ = 0;
  clear_has_endscanfreq();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::endscanfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.endScanFreq)
  return endscanfreq_;
}
inline void Detector_DetectorOptions::set_endscanfreq(::google::protobuf::int32 value) {
  set_has_endscanfreq();
  endscanfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.endScanFreq)
}

// required int32 loopNum = 5;
inline bool Detector_DetectorOptions::has_loopnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Detector_DetectorOptions::set_has_loopnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Detector_DetectorOptions::clear_has_loopnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Detector_DetectorOptions::clear_loopnum() {
  loopnum_ = 0;
  clear_has_loopnum();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::loopnum() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.loopNum)
  return loopnum_;
}
inline void Detector_DetectorOptions::set_loopnum(::google::protobuf::int32 value) {
  set_has_loopnum();
  loopnum_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.loopNum)
}

// required int32 spectrumMean = 6;
inline bool Detector_DetectorOptions::has_spectrummean() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Detector_DetectorOptions::set_has_spectrummean() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Detector_DetectorOptions::clear_has_spectrummean() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Detector_DetectorOptions::clear_spectrummean() {
  spectrummean_ = 0;
  clear_has_spectrummean();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::spectrummean() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.spectrumMean)
  return spectrummean_;
}
inline void Detector_DetectorOptions::set_spectrummean(::google::protobuf::int32 value) {
  set_has_spectrummean();
  spectrummean_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.spectrumMean)
}

// required bool convolution = 7;
inline bool Detector_DetectorOptions::has_convolution() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Detector_DetectorOptions::set_has_convolution() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Detector_DetectorOptions::clear_has_convolution() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Detector_DetectorOptions::clear_convolution() {
  convolution_ = false;
  clear_has_convolution();
}
inline bool Detector_DetectorOptions::convolution() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.convolution)
  return convolution_;
}
inline void Detector_DetectorOptions::set_convolution(bool value) {
  set_has_convolution();
  convolution_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.convolution)
}

// required int32 veracityThreshold = 8;
inline bool Detector_DetectorOptions::has_veracitythreshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Detector_DetectorOptions::set_has_veracitythreshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Detector_DetectorOptions::clear_has_veracitythreshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Detector_DetectorOptions::clear_veracitythreshold() {
  veracitythreshold_ = 0;
  clear_has_veracitythreshold();
}
inline ::google::protobuf::int32 Detector_DetectorOptions::veracitythreshold() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Detector.DetectorOptions.veracityThreshold)
  return veracitythreshold_;
}
inline void Detector_DetectorOptions::set_veracitythreshold(::google::protobuf::int32 value) {
  set_has_veracitythreshold();
  veracitythreshold_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Detector.DetectorOptions.veracityThreshold)
}

// -------------------------------------------------------------------

// Detector

// optional .RdsProtobuf.Detector.DetectorOptions options = 1;
inline bool Detector::has_options() const {
  return Message_case() == kOptions;
}
inline void Detector::set_has_options() {
  _oneof_case_[0] = kOptions;
}
inline void Detector::clear_options() {
  if (has_options()) {
    delete Message_.options_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Detector_DetectorOptions& Detector::options() const {
  return has_options() ? *Message_.options_
                      : ::RdsProtobuf::Detector_DetectorOptions::default_instance();
}
inline ::RdsProtobuf::Detector_DetectorOptions* Detector::mutable_options() {
  if (!has_options()) {
    clear_Message();
    set_has_options();
    Message_.options_ = new ::RdsProtobuf::Detector_DetectorOptions;
  }
  return Message_.options_;
}
inline ::RdsProtobuf::Detector_DetectorOptions* Detector::release_options() {
  if (has_options()) {
    clear_has_Message();
    ::RdsProtobuf::Detector_DetectorOptions* temp = Message_.options_;
    Message_.options_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Detector::set_allocated_options(::RdsProtobuf::Detector_DetectorOptions* options) {
  clear_Message();
  if (options) {
    set_has_options();
    Message_.options_ = options;
  }
}

inline bool Detector::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void Detector::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Detector::MessageCase Detector::Message_case() const {
  return Detector::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Analysis_AnalysisOptions

// required int32 chanIndex = 1;
inline bool Analysis_AnalysisOptions::has_chanindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Analysis_AnalysisOptions::set_has_chanindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Analysis_AnalysisOptions::clear_has_chanindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Analysis_AnalysisOptions::clear_chanindex() {
  chanindex_ = 0;
  clear_has_chanindex();
}
inline ::google::protobuf::int32 Analysis_AnalysisOptions::chanindex() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Analysis.AnalysisOptions.chanIndex)
  return chanindex_;
}
inline void Analysis_AnalysisOptions::set_chanindex(::google::protobuf::int32 value) {
  set_has_chanindex();
  chanindex_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Analysis.AnalysisOptions.chanIndex)
}

// required int32 duration = 2;
inline bool Analysis_AnalysisOptions::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Analysis_AnalysisOptions::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Analysis_AnalysisOptions::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Analysis_AnalysisOptions::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 Analysis_AnalysisOptions::duration() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Analysis.AnalysisOptions.duration)
  return duration_;
}
inline void Analysis_AnalysisOptions::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Analysis.AnalysisOptions.duration)
}

// required int32 centralFreq = 3;
inline bool Analysis_AnalysisOptions::has_centralfreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Analysis_AnalysisOptions::set_has_centralfreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Analysis_AnalysisOptions::clear_has_centralfreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Analysis_AnalysisOptions::clear_centralfreq() {
  centralfreq_ = 0;
  clear_has_centralfreq();
}
inline ::google::protobuf::int32 Analysis_AnalysisOptions::centralfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Analysis.AnalysisOptions.centralFreq)
  return centralfreq_;
}
inline void Analysis_AnalysisOptions::set_centralfreq(::google::protobuf::int32 value) {
  set_has_centralfreq();
  centralfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.Analysis.AnalysisOptions.centralFreq)
}

// required .RdsProtobuf.TimeFreqArea selected = 4;
inline bool Analysis_AnalysisOptions::has_selected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Analysis_AnalysisOptions::set_has_selected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Analysis_AnalysisOptions::clear_has_selected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Analysis_AnalysisOptions::clear_selected() {
  if (selected_ != NULL) selected_->::RdsProtobuf::TimeFreqArea::Clear();
  clear_has_selected();
}
inline const ::RdsProtobuf::TimeFreqArea& Analysis_AnalysisOptions::selected() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Analysis.AnalysisOptions.selected)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selected_ != NULL ? *selected_ : *default_instance().selected_;
#else
  return selected_ != NULL ? *selected_ : *default_instance_->selected_;
#endif
}
inline ::RdsProtobuf::TimeFreqArea* Analysis_AnalysisOptions::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) selected_ = new ::RdsProtobuf::TimeFreqArea;
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.Analysis.AnalysisOptions.selected)
  return selected_;
}
inline ::RdsProtobuf::TimeFreqArea* Analysis_AnalysisOptions::release_selected() {
  clear_has_selected();
  ::RdsProtobuf::TimeFreqArea* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline void Analysis_AnalysisOptions::set_allocated_selected(::RdsProtobuf::TimeFreqArea* selected) {
  delete selected_;
  selected_ = selected;
  if (selected) {
    set_has_selected();
  } else {
    clear_has_selected();
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.Analysis.AnalysisOptions.selected)
}

// required .RdsProtobuf.TimeFreqArea zoomed = 5;
inline bool Analysis_AnalysisOptions::has_zoomed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Analysis_AnalysisOptions::set_has_zoomed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Analysis_AnalysisOptions::clear_has_zoomed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Analysis_AnalysisOptions::clear_zoomed() {
  if (zoomed_ != NULL) zoomed_->::RdsProtobuf::TimeFreqArea::Clear();
  clear_has_zoomed();
}
inline const ::RdsProtobuf::TimeFreqArea& Analysis_AnalysisOptions::zoomed() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.Analysis.AnalysisOptions.zoomed)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return zoomed_ != NULL ? *zoomed_ : *default_instance().zoomed_;
#else
  return zoomed_ != NULL ? *zoomed_ : *default_instance_->zoomed_;
#endif
}
inline ::RdsProtobuf::TimeFreqArea* Analysis_AnalysisOptions::mutable_zoomed() {
  set_has_zoomed();
  if (zoomed_ == NULL) zoomed_ = new ::RdsProtobuf::TimeFreqArea;
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.Analysis.AnalysisOptions.zoomed)
  return zoomed_;
}
inline ::RdsProtobuf::TimeFreqArea* Analysis_AnalysisOptions::release_zoomed() {
  clear_has_zoomed();
  ::RdsProtobuf::TimeFreqArea* temp = zoomed_;
  zoomed_ = NULL;
  return temp;
}
inline void Analysis_AnalysisOptions::set_allocated_zoomed(::RdsProtobuf::TimeFreqArea* zoomed) {
  delete zoomed_;
  zoomed_ = zoomed;
  if (zoomed) {
    set_has_zoomed();
  } else {
    clear_has_zoomed();
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.Analysis.AnalysisOptions.zoomed)
}

// -------------------------------------------------------------------

// Analysis

// optional .RdsProtobuf.Analysis.AnalysisOptions options = 1;
inline bool Analysis::has_options() const {
  return Message_case() == kOptions;
}
inline void Analysis::set_has_options() {
  _oneof_case_[0] = kOptions;
}
inline void Analysis::clear_options() {
  if (has_options()) {
    delete Message_.options_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Analysis_AnalysisOptions& Analysis::options() const {
  return has_options() ? *Message_.options_
                      : ::RdsProtobuf::Analysis_AnalysisOptions::default_instance();
}
inline ::RdsProtobuf::Analysis_AnalysisOptions* Analysis::mutable_options() {
  if (!has_options()) {
    clear_Message();
    set_has_options();
    Message_.options_ = new ::RdsProtobuf::Analysis_AnalysisOptions;
  }
  return Message_.options_;
}
inline ::RdsProtobuf::Analysis_AnalysisOptions* Analysis::release_options() {
  if (has_options()) {
    clear_has_Message();
    ::RdsProtobuf::Analysis_AnalysisOptions* temp = Message_.options_;
    Message_.options_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Analysis::set_allocated_options(::RdsProtobuf::Analysis_AnalysisOptions* options) {
  clear_Message();
  if (options) {
    set_has_options();
    Message_.options_ = options;
  }
}

inline bool Analysis::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void Analysis::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Analysis::MessageCase Analysis::Message_case() const {
  return Analysis::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataStatus

// repeated bool status = 1;
inline int DataStatus::status_size() const {
  return status_.size();
}
inline void DataStatus::clear_status() {
  status_.Clear();
}
inline bool DataStatus::status(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DataStatus.status)
  return status_.Get(index);
}
inline void DataStatus::set_status(int index, bool value) {
  status_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.DataStatus.status)
}
inline void DataStatus::add_status(bool value) {
  status_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.DataStatus.status)
}
inline const ::google::protobuf::RepeatedField< bool >&
DataStatus::status() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.DataStatus.status)
  return status_;
}
inline ::google::protobuf::RepeatedField< bool >*
DataStatus::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.DataStatus.status)
  return &status_;
}

// required int32 length = 2;
inline bool DataStatus::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataStatus::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataStatus::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataStatus::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 DataStatus::length() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DataStatus.length)
  return length_;
}
inline void DataStatus::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DataStatus.length)
}

// -------------------------------------------------------------------

// LocationSpectrum

// required int32 index = 1;
inline bool LocationSpectrum::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationSpectrum::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationSpectrum::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationSpectrum::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 LocationSpectrum::index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.index)
  return index_;
}
inline void LocationSpectrum::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.index)
}

// repeated float data = 2;
inline int LocationSpectrum::data_size() const {
  return data_.size();
}
inline void LocationSpectrum::clear_data() {
  data_.Clear();
}
inline float LocationSpectrum::data(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.data)
  return data_.Get(index);
}
inline void LocationSpectrum::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.data)
}
inline void LocationSpectrum::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.LocationSpectrum.data)
}
inline const ::google::protobuf::RepeatedField< float >&
LocationSpectrum::data() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.LocationSpectrum.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
LocationSpectrum::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.LocationSpectrum.data)
  return &data_;
}

// required int32 length = 3;
inline bool LocationSpectrum::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationSpectrum::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationSpectrum::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationSpectrum::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 LocationSpectrum::length() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.length)
  return length_;
}
inline void LocationSpectrum::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.length)
}

// required double startFreq = 4;
inline bool LocationSpectrum::has_startfreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationSpectrum::set_has_startfreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationSpectrum::clear_has_startfreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationSpectrum::clear_startfreq() {
  startfreq_ = 0;
  clear_has_startfreq();
}
inline double LocationSpectrum::startfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.startFreq)
  return startfreq_;
}
inline void LocationSpectrum::set_startfreq(double value) {
  set_has_startfreq();
  startfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.startFreq)
}

// required double stepFreq = 5;
inline bool LocationSpectrum::has_stepfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocationSpectrum::set_has_stepfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocationSpectrum::clear_has_stepfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocationSpectrum::clear_stepfreq() {
  stepfreq_ = 0;
  clear_has_stepfreq();
}
inline double LocationSpectrum::stepfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.stepFreq)
  return stepfreq_;
}
inline void LocationSpectrum::set_stepfreq(double value) {
  set_has_stepfreq();
  stepfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.stepFreq)
}

// required int32 freqShift = 6;
inline bool LocationSpectrum::has_freqshift() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocationSpectrum::set_has_freqshift() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocationSpectrum::clear_has_freqshift() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocationSpectrum::clear_freqshift() {
  freqshift_ = 0;
  clear_has_freqshift();
}
inline ::google::protobuf::int32 LocationSpectrum::freqshift() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.freqShift)
  return freqshift_;
}
inline void LocationSpectrum::set_freqshift(::google::protobuf::int32 value) {
  set_has_freqshift();
  freqshift_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.freqShift)
}

// required int32 signalRange = 7;
inline bool LocationSpectrum::has_signalrange() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocationSpectrum::set_has_signalrange() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocationSpectrum::clear_has_signalrange() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocationSpectrum::clear_signalrange() {
  signalrange_ = 0;
  clear_has_signalrange();
}
inline ::google::protobuf::int32 LocationSpectrum::signalrange() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationSpectrum.signalRange)
  return signalrange_;
}
inline void LocationSpectrum::set_signalrange(::google::protobuf::int32 value) {
  set_has_signalrange();
  signalrange_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationSpectrum.signalRange)
}

// -------------------------------------------------------------------

// LocationXCov

// required int32 index = 1;
inline bool LocationXCov::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationXCov::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationXCov::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationXCov::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 LocationXCov::index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationXCov.index)
  return index_;
}
inline void LocationXCov::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationXCov.index)
}

// repeated float data = 2;
inline int LocationXCov::data_size() const {
  return data_.size();
}
inline void LocationXCov::clear_data() {
  data_.Clear();
}
inline float LocationXCov::data(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationXCov.data)
  return data_.Get(index);
}
inline void LocationXCov::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationXCov.data)
}
inline void LocationXCov::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.LocationXCov.data)
}
inline const ::google::protobuf::RepeatedField< float >&
LocationXCov::data() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.LocationXCov.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
LocationXCov::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.LocationXCov.data)
  return &data_;
}

// required float timeDiff = 3;
inline bool LocationXCov::has_timediff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationXCov::set_has_timediff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationXCov::clear_has_timediff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationXCov::clear_timediff() {
  timediff_ = 0;
  clear_has_timediff();
}
inline float LocationXCov::timediff() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationXCov.timeDiff)
  return timediff_;
}
inline void LocationXCov::set_timediff(float value) {
  set_has_timediff();
  timediff_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationXCov.timeDiff)
}

// required float veracity = 4;
inline bool LocationXCov::has_veracity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationXCov::set_has_veracity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationXCov::clear_has_veracity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationXCov::clear_veracity() {
  veracity_ = 0;
  clear_has_veracity();
}
inline float LocationXCov::veracity() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.LocationXCov.veracity)
  return veracity_;
}
inline void LocationXCov::set_veracity(float value) {
  set_has_veracity();
  veracity_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.LocationXCov.veracity)
}

// -------------------------------------------------------------------

// DetectorSpectrum

// required int32 index = 1;
inline bool DetectorSpectrum::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectorSpectrum::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectorSpectrum::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectorSpectrum::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 DetectorSpectrum::index() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.index)
  return index_;
}
inline void DetectorSpectrum::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.index)
}

// repeated float data = 2;
inline int DetectorSpectrum::data_size() const {
  return data_.size();
}
inline void DetectorSpectrum::clear_data() {
  data_.Clear();
}
inline float DetectorSpectrum::data(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.data)
  return data_.Get(index);
}
inline void DetectorSpectrum::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.data)
}
inline void DetectorSpectrum::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.DetectorSpectrum.data)
}
inline const ::google::protobuf::RepeatedField< float >&
DetectorSpectrum::data() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.DetectorSpectrum.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
DetectorSpectrum::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.DetectorSpectrum.data)
  return &data_;
}

// required int32 length = 3;
inline bool DetectorSpectrum::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectorSpectrum::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectorSpectrum::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectorSpectrum::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 DetectorSpectrum::length() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.length)
  return length_;
}
inline void DetectorSpectrum::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.length)
}

// required double startFreq = 4;
inline bool DetectorSpectrum::has_startfreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetectorSpectrum::set_has_startfreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetectorSpectrum::clear_has_startfreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetectorSpectrum::clear_startfreq() {
  startfreq_ = 0;
  clear_has_startfreq();
}
inline double DetectorSpectrum::startfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.startFreq)
  return startfreq_;
}
inline void DetectorSpectrum::set_startfreq(double value) {
  set_has_startfreq();
  startfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.startFreq)
}

// required double stepFreq = 5;
inline bool DetectorSpectrum::has_stepfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetectorSpectrum::set_has_stepfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetectorSpectrum::clear_has_stepfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetectorSpectrum::clear_stepfreq() {
  stepfreq_ = 0;
  clear_has_stepfreq();
}
inline double DetectorSpectrum::stepfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.stepFreq)
  return stepfreq_;
}
inline void DetectorSpectrum::set_stepfreq(double value) {
  set_has_stepfreq();
  stepfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.stepFreq)
}

// required int32 freqShift = 6;
inline bool DetectorSpectrum::has_freqshift() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetectorSpectrum::set_has_freqshift() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetectorSpectrum::clear_has_freqshift() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetectorSpectrum::clear_freqshift() {
  freqshift_ = 0;
  clear_has_freqshift();
}
inline ::google::protobuf::int32 DetectorSpectrum::freqshift() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.freqShift)
  return freqshift_;
}
inline void DetectorSpectrum::set_freqshift(::google::protobuf::int32 value) {
  set_has_freqshift();
  freqshift_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.freqShift)
}

// required int32 signalRange = 7;
inline bool DetectorSpectrum::has_signalrange() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetectorSpectrum::set_has_signalrange() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetectorSpectrum::clear_has_signalrange() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetectorSpectrum::clear_signalrange() {
  signalrange_ = 0;
  clear_has_signalrange();
}
inline ::google::protobuf::int32 DetectorSpectrum::signalrange() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.signalRange)
  return signalrange_;
}
inline void DetectorSpectrum::set_signalrange(::google::protobuf::int32 value) {
  set_has_signalrange();
  signalrange_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.signalRange)
}

// repeated int32 firstIndex = 8;
inline int DetectorSpectrum::firstindex_size() const {
  return firstindex_.size();
}
inline void DetectorSpectrum::clear_firstindex() {
  firstindex_.Clear();
}
inline ::google::protobuf::int32 DetectorSpectrum::firstindex(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.firstIndex)
  return firstindex_.Get(index);
}
inline void DetectorSpectrum::set_firstindex(int index, ::google::protobuf::int32 value) {
  firstindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.firstIndex)
}
inline void DetectorSpectrum::add_firstindex(::google::protobuf::int32 value) {
  firstindex_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.DetectorSpectrum.firstIndex)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DetectorSpectrum::firstindex() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.DetectorSpectrum.firstIndex)
  return firstindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DetectorSpectrum::mutable_firstindex() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.DetectorSpectrum.firstIndex)
  return &firstindex_;
}

// repeated int32 lastIndex = 9;
inline int DetectorSpectrum::lastindex_size() const {
  return lastindex_.size();
}
inline void DetectorSpectrum::clear_lastindex() {
  lastindex_.Clear();
}
inline ::google::protobuf::int32 DetectorSpectrum::lastindex(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.lastIndex)
  return lastindex_.Get(index);
}
inline void DetectorSpectrum::set_lastindex(int index, ::google::protobuf::int32 value) {
  lastindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.lastIndex)
}
inline void DetectorSpectrum::add_lastindex(::google::protobuf::int32 value) {
  lastindex_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.DetectorSpectrum.lastIndex)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DetectorSpectrum::lastindex() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.DetectorSpectrum.lastIndex)
  return lastindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DetectorSpectrum::mutable_lastindex() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.DetectorSpectrum.lastIndex)
  return &lastindex_;
}

// required int32 detectedNum = 10;
inline bool DetectorSpectrum::has_detectednum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DetectorSpectrum::set_has_detectednum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DetectorSpectrum::clear_has_detectednum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DetectorSpectrum::clear_detectednum() {
  detectednum_ = 0;
  clear_has_detectednum();
}
inline ::google::protobuf::int32 DetectorSpectrum::detectednum() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.detectedNum)
  return detectednum_;
}
inline void DetectorSpectrum::set_detectednum(::google::protobuf::int32 value) {
  set_has_detectednum();
  detectednum_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.detectedNum)
}

// required int32 centralFreq = 11;
inline bool DetectorSpectrum::has_centralfreq() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DetectorSpectrum::set_has_centralfreq() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DetectorSpectrum::clear_has_centralfreq() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DetectorSpectrum::clear_centralfreq() {
  centralfreq_ = 0;
  clear_has_centralfreq();
}
inline ::google::protobuf::int32 DetectorSpectrum::centralfreq() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.DetectorSpectrum.centralFreq)
  return centralfreq_;
}
inline void DetectorSpectrum::set_centralfreq(::google::protobuf::int32 value) {
  set_has_centralfreq();
  centralfreq_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.DetectorSpectrum.centralFreq)
}

// -------------------------------------------------------------------

// AnalysisSpectrogram

// repeated float data = 1;
inline int AnalysisSpectrogram::data_size() const {
  return data_.size();
}
inline void AnalysisSpectrogram::clear_data() {
  data_.Clear();
}
inline float AnalysisSpectrogram::data(int index) const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.AnalysisSpectrogram.data)
  return data_.Get(index);
}
inline void AnalysisSpectrogram::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.AnalysisSpectrogram.data)
}
inline void AnalysisSpectrogram::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:RdsProtobuf.AnalysisSpectrogram.data)
}
inline const ::google::protobuf::RepeatedField< float >&
AnalysisSpectrogram::data() const {
  // @@protoc_insertion_point(field_list:RdsProtobuf.AnalysisSpectrogram.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
AnalysisSpectrogram::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:RdsProtobuf.AnalysisSpectrogram.data)
  return &data_;
}

// required int32 length = 2;
inline bool AnalysisSpectrogram::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalysisSpectrogram::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalysisSpectrogram::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalysisSpectrogram::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 AnalysisSpectrogram::length() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.AnalysisSpectrogram.length)
  return length_;
}
inline void AnalysisSpectrogram::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.AnalysisSpectrogram.length)
}

// required int32 columns = 3;
inline bool AnalysisSpectrogram::has_columns() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalysisSpectrogram::set_has_columns() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalysisSpectrogram::clear_has_columns() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalysisSpectrogram::clear_columns() {
  columns_ = 0;
  clear_has_columns();
}
inline ::google::protobuf::int32 AnalysisSpectrogram::columns() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.AnalysisSpectrogram.columns)
  return columns_;
}
inline void AnalysisSpectrogram::set_columns(::google::protobuf::int32 value) {
  set_has_columns();
  columns_ = value;
  // @@protoc_insertion_point(field_set:RdsProtobuf.AnalysisSpectrogram.columns)
}

// required .RdsProtobuf.TimeFreqArea area = 4;
inline bool AnalysisSpectrogram::has_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalysisSpectrogram::set_has_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalysisSpectrogram::clear_has_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalysisSpectrogram::clear_area() {
  if (area_ != NULL) area_->::RdsProtobuf::TimeFreqArea::Clear();
  clear_has_area();
}
inline const ::RdsProtobuf::TimeFreqArea& AnalysisSpectrogram::area() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.AnalysisSpectrogram.area)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return area_ != NULL ? *area_ : *default_instance().area_;
#else
  return area_ != NULL ? *area_ : *default_instance_->area_;
#endif
}
inline ::RdsProtobuf::TimeFreqArea* AnalysisSpectrogram::mutable_area() {
  set_has_area();
  if (area_ == NULL) area_ = new ::RdsProtobuf::TimeFreqArea;
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.AnalysisSpectrogram.area)
  return area_;
}
inline ::RdsProtobuf::TimeFreqArea* AnalysisSpectrogram::release_area() {
  clear_has_area();
  ::RdsProtobuf::TimeFreqArea* temp = area_;
  area_ = NULL;
  return temp;
}
inline void AnalysisSpectrogram::set_allocated_area(::RdsProtobuf::TimeFreqArea* area) {
  delete area_;
  area_ = area;
  if (area) {
    set_has_area();
  } else {
    clear_has_area();
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.AnalysisSpectrogram.area)
}

// -------------------------------------------------------------------

// ClientMessage_GetMessage

// optional .RdsProtobuf.Mode mode = 1;
inline bool ClientMessage_GetMessage::has_mode() const {
  return Message_case() == kMode;
}
inline void ClientMessage_GetMessage::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void ClientMessage_GetMessage::clear_mode() {
  if (has_mode()) {
    delete Message_.mode_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Mode& ClientMessage_GetMessage::mode() const {
  return has_mode() ? *Message_.mode_
                      : ::RdsProtobuf::Mode::default_instance();
}
inline ::RdsProtobuf::Mode* ClientMessage_GetMessage::mutable_mode() {
  if (!has_mode()) {
    clear_Message();
    set_has_mode();
    Message_.mode_ = new ::RdsProtobuf::Mode;
  }
  return Message_.mode_;
}
inline ::RdsProtobuf::Mode* ClientMessage_GetMessage::release_mode() {
  if (has_mode()) {
    clear_has_Message();
    ::RdsProtobuf::Mode* temp = Message_.mode_;
    Message_.mode_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_GetMessage::set_allocated_mode(::RdsProtobuf::Mode* mode) {
  clear_Message();
  if (mode) {
    set_has_mode();
    Message_.mode_ = mode;
  }
}

// optional .RdsProtobuf.System system = 2;
inline bool ClientMessage_GetMessage::has_system() const {
  return Message_case() == kSystem;
}
inline void ClientMessage_GetMessage::set_has_system() {
  _oneof_case_[0] = kSystem;
}
inline void ClientMessage_GetMessage::clear_system() {
  if (has_system()) {
    delete Message_.system_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::System& ClientMessage_GetMessage::system() const {
  return has_system() ? *Message_.system_
                      : ::RdsProtobuf::System::default_instance();
}
inline ::RdsProtobuf::System* ClientMessage_GetMessage::mutable_system() {
  if (!has_system()) {
    clear_Message();
    set_has_system();
    Message_.system_ = new ::RdsProtobuf::System;
  }
  return Message_.system_;
}
inline ::RdsProtobuf::System* ClientMessage_GetMessage::release_system() {
  if (has_system()) {
    clear_has_Message();
    ::RdsProtobuf::System* temp = Message_.system_;
    Message_.system_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_GetMessage::set_allocated_system(::RdsProtobuf::System* system) {
  clear_Message();
  if (system) {
    set_has_system();
    Message_.system_ = system;
  }
}

// optional .RdsProtobuf.Location location = 3;
inline bool ClientMessage_GetMessage::has_location() const {
  return Message_case() == kLocation;
}
inline void ClientMessage_GetMessage::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline void ClientMessage_GetMessage::clear_location() {
  if (has_location()) {
    delete Message_.location_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Location& ClientMessage_GetMessage::location() const {
  return has_location() ? *Message_.location_
                      : ::RdsProtobuf::Location::default_instance();
}
inline ::RdsProtobuf::Location* ClientMessage_GetMessage::mutable_location() {
  if (!has_location()) {
    clear_Message();
    set_has_location();
    Message_.location_ = new ::RdsProtobuf::Location;
  }
  return Message_.location_;
}
inline ::RdsProtobuf::Location* ClientMessage_GetMessage::release_location() {
  if (has_location()) {
    clear_has_Message();
    ::RdsProtobuf::Location* temp = Message_.location_;
    Message_.location_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_GetMessage::set_allocated_location(::RdsProtobuf::Location* location) {
  clear_Message();
  if (location) {
    set_has_location();
    Message_.location_ = location;
  }
}

// optional .RdsProtobuf.Detector detector = 4;
inline bool ClientMessage_GetMessage::has_detector() const {
  return Message_case() == kDetector;
}
inline void ClientMessage_GetMessage::set_has_detector() {
  _oneof_case_[0] = kDetector;
}
inline void ClientMessage_GetMessage::clear_detector() {
  if (has_detector()) {
    delete Message_.detector_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Detector& ClientMessage_GetMessage::detector() const {
  return has_detector() ? *Message_.detector_
                      : ::RdsProtobuf::Detector::default_instance();
}
inline ::RdsProtobuf::Detector* ClientMessage_GetMessage::mutable_detector() {
  if (!has_detector()) {
    clear_Message();
    set_has_detector();
    Message_.detector_ = new ::RdsProtobuf::Detector;
  }
  return Message_.detector_;
}
inline ::RdsProtobuf::Detector* ClientMessage_GetMessage::release_detector() {
  if (has_detector()) {
    clear_has_Message();
    ::RdsProtobuf::Detector* temp = Message_.detector_;
    Message_.detector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_GetMessage::set_allocated_detector(::RdsProtobuf::Detector* detector) {
  clear_Message();
  if (detector) {
    set_has_detector();
    Message_.detector_ = detector;
  }
}

// optional .RdsProtobuf.Analysis analysis = 5;
inline bool ClientMessage_GetMessage::has_analysis() const {
  return Message_case() == kAnalysis;
}
inline void ClientMessage_GetMessage::set_has_analysis() {
  _oneof_case_[0] = kAnalysis;
}
inline void ClientMessage_GetMessage::clear_analysis() {
  if (has_analysis()) {
    delete Message_.analysis_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Analysis& ClientMessage_GetMessage::analysis() const {
  return has_analysis() ? *Message_.analysis_
                      : ::RdsProtobuf::Analysis::default_instance();
}
inline ::RdsProtobuf::Analysis* ClientMessage_GetMessage::mutable_analysis() {
  if (!has_analysis()) {
    clear_Message();
    set_has_analysis();
    Message_.analysis_ = new ::RdsProtobuf::Analysis;
  }
  return Message_.analysis_;
}
inline ::RdsProtobuf::Analysis* ClientMessage_GetMessage::release_analysis() {
  if (has_analysis()) {
    clear_has_Message();
    ::RdsProtobuf::Analysis* temp = Message_.analysis_;
    Message_.analysis_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_GetMessage::set_allocated_analysis(::RdsProtobuf::Analysis* analysis) {
  clear_Message();
  if (analysis) {
    set_has_analysis();
    Message_.analysis_ = analysis;
  }
}

inline bool ClientMessage_GetMessage::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void ClientMessage_GetMessage::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ClientMessage_GetMessage::MessageCase ClientMessage_GetMessage::Message_case() const {
  return ClientMessage_GetMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientMessage_SetMessage

// optional .RdsProtobuf.Mode mode = 1;
inline bool ClientMessage_SetMessage::has_mode() const {
  return Message_case() == kMode;
}
inline void ClientMessage_SetMessage::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void ClientMessage_SetMessage::clear_mode() {
  if (has_mode()) {
    delete Message_.mode_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Mode& ClientMessage_SetMessage::mode() const {
  return has_mode() ? *Message_.mode_
                      : ::RdsProtobuf::Mode::default_instance();
}
inline ::RdsProtobuf::Mode* ClientMessage_SetMessage::mutable_mode() {
  if (!has_mode()) {
    clear_Message();
    set_has_mode();
    Message_.mode_ = new ::RdsProtobuf::Mode;
  }
  return Message_.mode_;
}
inline ::RdsProtobuf::Mode* ClientMessage_SetMessage::release_mode() {
  if (has_mode()) {
    clear_has_Message();
    ::RdsProtobuf::Mode* temp = Message_.mode_;
    Message_.mode_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_SetMessage::set_allocated_mode(::RdsProtobuf::Mode* mode) {
  clear_Message();
  if (mode) {
    set_has_mode();
    Message_.mode_ = mode;
  }
}

// optional .RdsProtobuf.System system = 2;
inline bool ClientMessage_SetMessage::has_system() const {
  return Message_case() == kSystem;
}
inline void ClientMessage_SetMessage::set_has_system() {
  _oneof_case_[0] = kSystem;
}
inline void ClientMessage_SetMessage::clear_system() {
  if (has_system()) {
    delete Message_.system_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::System& ClientMessage_SetMessage::system() const {
  return has_system() ? *Message_.system_
                      : ::RdsProtobuf::System::default_instance();
}
inline ::RdsProtobuf::System* ClientMessage_SetMessage::mutable_system() {
  if (!has_system()) {
    clear_Message();
    set_has_system();
    Message_.system_ = new ::RdsProtobuf::System;
  }
  return Message_.system_;
}
inline ::RdsProtobuf::System* ClientMessage_SetMessage::release_system() {
  if (has_system()) {
    clear_has_Message();
    ::RdsProtobuf::System* temp = Message_.system_;
    Message_.system_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_SetMessage::set_allocated_system(::RdsProtobuf::System* system) {
  clear_Message();
  if (system) {
    set_has_system();
    Message_.system_ = system;
  }
}

// optional .RdsProtobuf.Location location = 3;
inline bool ClientMessage_SetMessage::has_location() const {
  return Message_case() == kLocation;
}
inline void ClientMessage_SetMessage::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline void ClientMessage_SetMessage::clear_location() {
  if (has_location()) {
    delete Message_.location_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Location& ClientMessage_SetMessage::location() const {
  return has_location() ? *Message_.location_
                      : ::RdsProtobuf::Location::default_instance();
}
inline ::RdsProtobuf::Location* ClientMessage_SetMessage::mutable_location() {
  if (!has_location()) {
    clear_Message();
    set_has_location();
    Message_.location_ = new ::RdsProtobuf::Location;
  }
  return Message_.location_;
}
inline ::RdsProtobuf::Location* ClientMessage_SetMessage::release_location() {
  if (has_location()) {
    clear_has_Message();
    ::RdsProtobuf::Location* temp = Message_.location_;
    Message_.location_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_SetMessage::set_allocated_location(::RdsProtobuf::Location* location) {
  clear_Message();
  if (location) {
    set_has_location();
    Message_.location_ = location;
  }
}

// optional .RdsProtobuf.Detector detector = 4;
inline bool ClientMessage_SetMessage::has_detector() const {
  return Message_case() == kDetector;
}
inline void ClientMessage_SetMessage::set_has_detector() {
  _oneof_case_[0] = kDetector;
}
inline void ClientMessage_SetMessage::clear_detector() {
  if (has_detector()) {
    delete Message_.detector_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Detector& ClientMessage_SetMessage::detector() const {
  return has_detector() ? *Message_.detector_
                      : ::RdsProtobuf::Detector::default_instance();
}
inline ::RdsProtobuf::Detector* ClientMessage_SetMessage::mutable_detector() {
  if (!has_detector()) {
    clear_Message();
    set_has_detector();
    Message_.detector_ = new ::RdsProtobuf::Detector;
  }
  return Message_.detector_;
}
inline ::RdsProtobuf::Detector* ClientMessage_SetMessage::release_detector() {
  if (has_detector()) {
    clear_has_Message();
    ::RdsProtobuf::Detector* temp = Message_.detector_;
    Message_.detector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_SetMessage::set_allocated_detector(::RdsProtobuf::Detector* detector) {
  clear_Message();
  if (detector) {
    set_has_detector();
    Message_.detector_ = detector;
  }
}

// optional .RdsProtobuf.Analysis analysis = 5;
inline bool ClientMessage_SetMessage::has_analysis() const {
  return Message_case() == kAnalysis;
}
inline void ClientMessage_SetMessage::set_has_analysis() {
  _oneof_case_[0] = kAnalysis;
}
inline void ClientMessage_SetMessage::clear_analysis() {
  if (has_analysis()) {
    delete Message_.analysis_;
    clear_has_Message();
  }
}
inline const ::RdsProtobuf::Analysis& ClientMessage_SetMessage::analysis() const {
  return has_analysis() ? *Message_.analysis_
                      : ::RdsProtobuf::Analysis::default_instance();
}
inline ::RdsProtobuf::Analysis* ClientMessage_SetMessage::mutable_analysis() {
  if (!has_analysis()) {
    clear_Message();
    set_has_analysis();
    Message_.analysis_ = new ::RdsProtobuf::Analysis;
  }
  return Message_.analysis_;
}
inline ::RdsProtobuf::Analysis* ClientMessage_SetMessage::release_analysis() {
  if (has_analysis()) {
    clear_has_Message();
    ::RdsProtobuf::Analysis* temp = Message_.analysis_;
    Message_.analysis_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage_SetMessage::set_allocated_analysis(::RdsProtobuf::Analysis* analysis) {
  clear_Message();
  if (analysis) {
    set_has_analysis();
    Message_.analysis_ = analysis;
  }
}

inline bool ClientMessage_SetMessage::has_Message() {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void ClientMessage_SetMessage::clear_has_Message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ClientMessage_SetMessage::MessageCase ClientMessage_SetMessage::Message_case() const {
  return ClientMessage_SetMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientMessage

// optional .RdsProtobuf.ClientMessage.GetMessage get = 1;
inline bool ClientMessage::has_get() const {
  return MessageType_case() == kGet;
}
inline void ClientMessage::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void ClientMessage::clear_get() {
  if (has_get()) {
    delete MessageType_.get_;
    clear_has_MessageType();
  }
}
inline const ::RdsProtobuf::ClientMessage_GetMessage& ClientMessage::get() const {
  return has_get() ? *MessageType_.get_
                      : ::RdsProtobuf::ClientMessage_GetMessage::default_instance();
}
inline ::RdsProtobuf::ClientMessage_GetMessage* ClientMessage::mutable_get() {
  if (!has_get()) {
    clear_MessageType();
    set_has_get();
    MessageType_.get_ = new ::RdsProtobuf::ClientMessage_GetMessage;
  }
  return MessageType_.get_;
}
inline ::RdsProtobuf::ClientMessage_GetMessage* ClientMessage::release_get() {
  if (has_get()) {
    clear_has_MessageType();
    ::RdsProtobuf::ClientMessage_GetMessage* temp = MessageType_.get_;
    MessageType_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage::set_allocated_get(::RdsProtobuf::ClientMessage_GetMessage* get) {
  clear_MessageType();
  if (get) {
    set_has_get();
    MessageType_.get_ = get;
  }
}

// optional .RdsProtobuf.ClientMessage.SetMessage set = 2;
inline bool ClientMessage::has_set() const {
  return MessageType_case() == kSet;
}
inline void ClientMessage::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void ClientMessage::clear_set() {
  if (has_set()) {
    delete MessageType_.set_;
    clear_has_MessageType();
  }
}
inline const ::RdsProtobuf::ClientMessage_SetMessage& ClientMessage::set() const {
  return has_set() ? *MessageType_.set_
                      : ::RdsProtobuf::ClientMessage_SetMessage::default_instance();
}
inline ::RdsProtobuf::ClientMessage_SetMessage* ClientMessage::mutable_set() {
  if (!has_set()) {
    clear_MessageType();
    set_has_set();
    MessageType_.set_ = new ::RdsProtobuf::ClientMessage_SetMessage;
  }
  return MessageType_.set_;
}
inline ::RdsProtobuf::ClientMessage_SetMessage* ClientMessage::release_set() {
  if (has_set()) {
    clear_has_MessageType();
    ::RdsProtobuf::ClientMessage_SetMessage* temp = MessageType_.set_;
    MessageType_.set_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMessage::set_allocated_set(::RdsProtobuf::ClientMessage_SetMessage* set) {
  clear_MessageType();
  if (set) {
    set_has_set();
    MessageType_.set_ = set;
  }
}

inline bool ClientMessage::has_MessageType() {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void ClientMessage::clear_has_MessageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline ClientMessage::MessageTypeCase ClientMessage::MessageType_case() const {
  return ClientMessage::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage_CurrentMessage

// optional .RdsProtobuf.Mode mode = 1;
inline bool ServerMessage_CurrentMessage::has_mode() const {
  return Request_case() == kMode;
}
inline void ServerMessage_CurrentMessage::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void ServerMessage_CurrentMessage::clear_mode() {
  if (has_mode()) {
    delete Request_.mode_;
    clear_has_Request();
  }
}
inline const ::RdsProtobuf::Mode& ServerMessage_CurrentMessage::mode() const {
  return has_mode() ? *Request_.mode_
                      : ::RdsProtobuf::Mode::default_instance();
}
inline ::RdsProtobuf::Mode* ServerMessage_CurrentMessage::mutable_mode() {
  if (!has_mode()) {
    clear_Request();
    set_has_mode();
    Request_.mode_ = new ::RdsProtobuf::Mode;
  }
  return Request_.mode_;
}
inline ::RdsProtobuf::Mode* ServerMessage_CurrentMessage::release_mode() {
  if (has_mode()) {
    clear_has_Request();
    ::RdsProtobuf::Mode* temp = Request_.mode_;
    Request_.mode_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_CurrentMessage::set_allocated_mode(::RdsProtobuf::Mode* mode) {
  clear_Request();
  if (mode) {
    set_has_mode();
    Request_.mode_ = mode;
  }
}

// optional .RdsProtobuf.System system = 2;
inline bool ServerMessage_CurrentMessage::has_system() const {
  return Request_case() == kSystem;
}
inline void ServerMessage_CurrentMessage::set_has_system() {
  _oneof_case_[0] = kSystem;
}
inline void ServerMessage_CurrentMessage::clear_system() {
  if (has_system()) {
    delete Request_.system_;
    clear_has_Request();
  }
}
inline const ::RdsProtobuf::System& ServerMessage_CurrentMessage::system() const {
  return has_system() ? *Request_.system_
                      : ::RdsProtobuf::System::default_instance();
}
inline ::RdsProtobuf::System* ServerMessage_CurrentMessage::mutable_system() {
  if (!has_system()) {
    clear_Request();
    set_has_system();
    Request_.system_ = new ::RdsProtobuf::System;
  }
  return Request_.system_;
}
inline ::RdsProtobuf::System* ServerMessage_CurrentMessage::release_system() {
  if (has_system()) {
    clear_has_Request();
    ::RdsProtobuf::System* temp = Request_.system_;
    Request_.system_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_CurrentMessage::set_allocated_system(::RdsProtobuf::System* system) {
  clear_Request();
  if (system) {
    set_has_system();
    Request_.system_ = system;
  }
}

// optional .RdsProtobuf.Location location = 3;
inline bool ServerMessage_CurrentMessage::has_location() const {
  return Request_case() == kLocation;
}
inline void ServerMessage_CurrentMessage::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline void ServerMessage_CurrentMessage::clear_location() {
  if (has_location()) {
    delete Request_.location_;
    clear_has_Request();
  }
}
inline const ::RdsProtobuf::Location& ServerMessage_CurrentMessage::location() const {
  return has_location() ? *Request_.location_
                      : ::RdsProtobuf::Location::default_instance();
}
inline ::RdsProtobuf::Location* ServerMessage_CurrentMessage::mutable_location() {
  if (!has_location()) {
    clear_Request();
    set_has_location();
    Request_.location_ = new ::RdsProtobuf::Location;
  }
  return Request_.location_;
}
inline ::RdsProtobuf::Location* ServerMessage_CurrentMessage::release_location() {
  if (has_location()) {
    clear_has_Request();
    ::RdsProtobuf::Location* temp = Request_.location_;
    Request_.location_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_CurrentMessage::set_allocated_location(::RdsProtobuf::Location* location) {
  clear_Request();
  if (location) {
    set_has_location();
    Request_.location_ = location;
  }
}

// optional .RdsProtobuf.Detector detector = 4;
inline bool ServerMessage_CurrentMessage::has_detector() const {
  return Request_case() == kDetector;
}
inline void ServerMessage_CurrentMessage::set_has_detector() {
  _oneof_case_[0] = kDetector;
}
inline void ServerMessage_CurrentMessage::clear_detector() {
  if (has_detector()) {
    delete Request_.detector_;
    clear_has_Request();
  }
}
inline const ::RdsProtobuf::Detector& ServerMessage_CurrentMessage::detector() const {
  return has_detector() ? *Request_.detector_
                      : ::RdsProtobuf::Detector::default_instance();
}
inline ::RdsProtobuf::Detector* ServerMessage_CurrentMessage::mutable_detector() {
  if (!has_detector()) {
    clear_Request();
    set_has_detector();
    Request_.detector_ = new ::RdsProtobuf::Detector;
  }
  return Request_.detector_;
}
inline ::RdsProtobuf::Detector* ServerMessage_CurrentMessage::release_detector() {
  if (has_detector()) {
    clear_has_Request();
    ::RdsProtobuf::Detector* temp = Request_.detector_;
    Request_.detector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_CurrentMessage::set_allocated_detector(::RdsProtobuf::Detector* detector) {
  clear_Request();
  if (detector) {
    set_has_detector();
    Request_.detector_ = detector;
  }
}

// optional .RdsProtobuf.Analysis analysis = 5;
inline bool ServerMessage_CurrentMessage::has_analysis() const {
  return Request_case() == kAnalysis;
}
inline void ServerMessage_CurrentMessage::set_has_analysis() {
  _oneof_case_[0] = kAnalysis;
}
inline void ServerMessage_CurrentMessage::clear_analysis() {
  if (has_analysis()) {
    delete Request_.analysis_;
    clear_has_Request();
  }
}
inline const ::RdsProtobuf::Analysis& ServerMessage_CurrentMessage::analysis() const {
  return has_analysis() ? *Request_.analysis_
                      : ::RdsProtobuf::Analysis::default_instance();
}
inline ::RdsProtobuf::Analysis* ServerMessage_CurrentMessage::mutable_analysis() {
  if (!has_analysis()) {
    clear_Request();
    set_has_analysis();
    Request_.analysis_ = new ::RdsProtobuf::Analysis;
  }
  return Request_.analysis_;
}
inline ::RdsProtobuf::Analysis* ServerMessage_CurrentMessage::release_analysis() {
  if (has_analysis()) {
    clear_has_Request();
    ::RdsProtobuf::Analysis* temp = Request_.analysis_;
    Request_.analysis_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_CurrentMessage::set_allocated_analysis(::RdsProtobuf::Analysis* analysis) {
  clear_Request();
  if (analysis) {
    set_has_analysis();
    Request_.analysis_ = analysis;
  }
}

inline bool ServerMessage_CurrentMessage::has_Request() {
  return Request_case() != REQUEST_NOT_SET;
}
inline void ServerMessage_CurrentMessage::clear_has_Request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline ServerMessage_CurrentMessage::RequestCase ServerMessage_CurrentMessage::Request_case() const {
  return ServerMessage_CurrentMessage::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage_DataMessage

// optional .RdsProtobuf.LocationSpectrum location_Spectrum = 1;
inline bool ServerMessage_DataMessage::has_location_spectrum() const {
  return RequestType_case() == kLocationSpectrum;
}
inline void ServerMessage_DataMessage::set_has_location_spectrum() {
  _oneof_case_[0] = kLocationSpectrum;
}
inline void ServerMessage_DataMessage::clear_location_spectrum() {
  if (has_location_spectrum()) {
    delete RequestType_.location_spectrum_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::LocationSpectrum& ServerMessage_DataMessage::location_spectrum() const {
  return has_location_spectrum() ? *RequestType_.location_spectrum_
                      : ::RdsProtobuf::LocationSpectrum::default_instance();
}
inline ::RdsProtobuf::LocationSpectrum* ServerMessage_DataMessage::mutable_location_spectrum() {
  if (!has_location_spectrum()) {
    clear_RequestType();
    set_has_location_spectrum();
    RequestType_.location_spectrum_ = new ::RdsProtobuf::LocationSpectrum;
  }
  return RequestType_.location_spectrum_;
}
inline ::RdsProtobuf::LocationSpectrum* ServerMessage_DataMessage::release_location_spectrum() {
  if (has_location_spectrum()) {
    clear_has_RequestType();
    ::RdsProtobuf::LocationSpectrum* temp = RequestType_.location_spectrum_;
    RequestType_.location_spectrum_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_DataMessage::set_allocated_location_spectrum(::RdsProtobuf::LocationSpectrum* location_spectrum) {
  clear_RequestType();
  if (location_spectrum) {
    set_has_location_spectrum();
    RequestType_.location_spectrum_ = location_spectrum;
  }
}

// optional .RdsProtobuf.LocationXCov location_XCov = 2;
inline bool ServerMessage_DataMessage::has_location_xcov() const {
  return RequestType_case() == kLocationXCov;
}
inline void ServerMessage_DataMessage::set_has_location_xcov() {
  _oneof_case_[0] = kLocationXCov;
}
inline void ServerMessage_DataMessage::clear_location_xcov() {
  if (has_location_xcov()) {
    delete RequestType_.location_xcov_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::LocationXCov& ServerMessage_DataMessage::location_xcov() const {
  return has_location_xcov() ? *RequestType_.location_xcov_
                      : ::RdsProtobuf::LocationXCov::default_instance();
}
inline ::RdsProtobuf::LocationXCov* ServerMessage_DataMessage::mutable_location_xcov() {
  if (!has_location_xcov()) {
    clear_RequestType();
    set_has_location_xcov();
    RequestType_.location_xcov_ = new ::RdsProtobuf::LocationXCov;
  }
  return RequestType_.location_xcov_;
}
inline ::RdsProtobuf::LocationXCov* ServerMessage_DataMessage::release_location_xcov() {
  if (has_location_xcov()) {
    clear_has_RequestType();
    ::RdsProtobuf::LocationXCov* temp = RequestType_.location_xcov_;
    RequestType_.location_xcov_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_DataMessage::set_allocated_location_xcov(::RdsProtobuf::LocationXCov* location_xcov) {
  clear_RequestType();
  if (location_xcov) {
    set_has_location_xcov();
    RequestType_.location_xcov_ = location_xcov;
  }
}

// optional .RdsProtobuf.DataStatus data_Status = 3;
inline bool ServerMessage_DataMessage::has_data_status() const {
  return RequestType_case() == kDataStatus;
}
inline void ServerMessage_DataMessage::set_has_data_status() {
  _oneof_case_[0] = kDataStatus;
}
inline void ServerMessage_DataMessage::clear_data_status() {
  if (has_data_status()) {
    delete RequestType_.data_status_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::DataStatus& ServerMessage_DataMessage::data_status() const {
  return has_data_status() ? *RequestType_.data_status_
                      : ::RdsProtobuf::DataStatus::default_instance();
}
inline ::RdsProtobuf::DataStatus* ServerMessage_DataMessage::mutable_data_status() {
  if (!has_data_status()) {
    clear_RequestType();
    set_has_data_status();
    RequestType_.data_status_ = new ::RdsProtobuf::DataStatus;
  }
  return RequestType_.data_status_;
}
inline ::RdsProtobuf::DataStatus* ServerMessage_DataMessage::release_data_status() {
  if (has_data_status()) {
    clear_has_RequestType();
    ::RdsProtobuf::DataStatus* temp = RequestType_.data_status_;
    RequestType_.data_status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_DataMessage::set_allocated_data_status(::RdsProtobuf::DataStatus* data_status) {
  clear_RequestType();
  if (data_status) {
    set_has_data_status();
    RequestType_.data_status_ = data_status;
  }
}

// optional .RdsProtobuf.DetectorSpectrum detector_Spectrum = 4;
inline bool ServerMessage_DataMessage::has_detector_spectrum() const {
  return RequestType_case() == kDetectorSpectrum;
}
inline void ServerMessage_DataMessage::set_has_detector_spectrum() {
  _oneof_case_[0] = kDetectorSpectrum;
}
inline void ServerMessage_DataMessage::clear_detector_spectrum() {
  if (has_detector_spectrum()) {
    delete RequestType_.detector_spectrum_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::DetectorSpectrum& ServerMessage_DataMessage::detector_spectrum() const {
  return has_detector_spectrum() ? *RequestType_.detector_spectrum_
                      : ::RdsProtobuf::DetectorSpectrum::default_instance();
}
inline ::RdsProtobuf::DetectorSpectrum* ServerMessage_DataMessage::mutable_detector_spectrum() {
  if (!has_detector_spectrum()) {
    clear_RequestType();
    set_has_detector_spectrum();
    RequestType_.detector_spectrum_ = new ::RdsProtobuf::DetectorSpectrum;
  }
  return RequestType_.detector_spectrum_;
}
inline ::RdsProtobuf::DetectorSpectrum* ServerMessage_DataMessage::release_detector_spectrum() {
  if (has_detector_spectrum()) {
    clear_has_RequestType();
    ::RdsProtobuf::DetectorSpectrum* temp = RequestType_.detector_spectrum_;
    RequestType_.detector_spectrum_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_DataMessage::set_allocated_detector_spectrum(::RdsProtobuf::DetectorSpectrum* detector_spectrum) {
  clear_RequestType();
  if (detector_spectrum) {
    set_has_detector_spectrum();
    RequestType_.detector_spectrum_ = detector_spectrum;
  }
}

// optional .RdsProtobuf.AnalysisSpectrogram analysis_Spectrogram = 5;
inline bool ServerMessage_DataMessage::has_analysis_spectrogram() const {
  return RequestType_case() == kAnalysisSpectrogram;
}
inline void ServerMessage_DataMessage::set_has_analysis_spectrogram() {
  _oneof_case_[0] = kAnalysisSpectrogram;
}
inline void ServerMessage_DataMessage::clear_analysis_spectrogram() {
  if (has_analysis_spectrogram()) {
    delete RequestType_.analysis_spectrogram_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::AnalysisSpectrogram& ServerMessage_DataMessage::analysis_spectrogram() const {
  return has_analysis_spectrogram() ? *RequestType_.analysis_spectrogram_
                      : ::RdsProtobuf::AnalysisSpectrogram::default_instance();
}
inline ::RdsProtobuf::AnalysisSpectrogram* ServerMessage_DataMessage::mutable_analysis_spectrogram() {
  if (!has_analysis_spectrogram()) {
    clear_RequestType();
    set_has_analysis_spectrogram();
    RequestType_.analysis_spectrogram_ = new ::RdsProtobuf::AnalysisSpectrogram;
  }
  return RequestType_.analysis_spectrogram_;
}
inline ::RdsProtobuf::AnalysisSpectrogram* ServerMessage_DataMessage::release_analysis_spectrogram() {
  if (has_analysis_spectrogram()) {
    clear_has_RequestType();
    ::RdsProtobuf::AnalysisSpectrogram* temp = RequestType_.analysis_spectrogram_;
    RequestType_.analysis_spectrogram_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_DataMessage::set_allocated_analysis_spectrogram(::RdsProtobuf::AnalysisSpectrogram* analysis_spectrogram) {
  clear_RequestType();
  if (analysis_spectrogram) {
    set_has_analysis_spectrogram();
    RequestType_.analysis_spectrogram_ = analysis_spectrogram;
  }
}

inline bool ServerMessage_DataMessage::has_RequestType() {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
inline void ServerMessage_DataMessage::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline ServerMessage_DataMessage::RequestTypeCase ServerMessage_DataMessage::RequestType_case() const {
  return ServerMessage_DataMessage::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage_AnswerMessage_Error

// required string str = 1;
inline bool ServerMessage_AnswerMessage_Error::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage_AnswerMessage_Error::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage_AnswerMessage_Error::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage_AnswerMessage_Error::clear_str() {
  if (str_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& ServerMessage_AnswerMessage_Error::str() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ServerMessage.AnswerMessage.Error.str)
  return *str_;
}
inline void ServerMessage_AnswerMessage_Error::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.ServerMessage.AnswerMessage.Error.str)
}
inline void ServerMessage_AnswerMessage_Error::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.ServerMessage.AnswerMessage.Error.str)
}
inline void ServerMessage_AnswerMessage_Error::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.ServerMessage.AnswerMessage.Error.str)
}
inline ::std::string* ServerMessage_AnswerMessage_Error::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.ServerMessage.AnswerMessage.Error.str)
  return str_;
}
inline ::std::string* ServerMessage_AnswerMessage_Error::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerMessage_AnswerMessage_Error::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.ServerMessage.AnswerMessage.Error.str)
}

// -------------------------------------------------------------------

// ServerMessage_AnswerMessage_Confirmation

// required string str = 1;
inline bool ServerMessage_AnswerMessage_Confirmation::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage_AnswerMessage_Confirmation::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage_AnswerMessage_Confirmation::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage_AnswerMessage_Confirmation::clear_str() {
  if (str_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& ServerMessage_AnswerMessage_Confirmation::str() const {
  // @@protoc_insertion_point(field_get:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation.str)
  return *str_;
}
inline void ServerMessage_AnswerMessage_Confirmation::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(value);
  // @@protoc_insertion_point(field_set:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation.str)
}
inline void ServerMessage_AnswerMessage_Confirmation::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(value);
  // @@protoc_insertion_point(field_set_char:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation.str)
}
inline void ServerMessage_AnswerMessage_Confirmation::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation.str)
}
inline ::std::string* ServerMessage_AnswerMessage_Confirmation::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation.str)
  return str_;
}
inline ::std::string* ServerMessage_AnswerMessage_Confirmation::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerMessage_AnswerMessage_Confirmation::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RdsProtobuf.ServerMessage.AnswerMessage.Confirmation.str)
}

// -------------------------------------------------------------------

// ServerMessage_AnswerMessage

// optional .RdsProtobuf.ServerMessage.AnswerMessage.Error error = 1;
inline bool ServerMessage_AnswerMessage::has_error() const {
  return RequestType_case() == kError;
}
inline void ServerMessage_AnswerMessage::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void ServerMessage_AnswerMessage::clear_error() {
  if (has_error()) {
    delete RequestType_.error_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::ServerMessage_AnswerMessage_Error& ServerMessage_AnswerMessage::error() const {
  return has_error() ? *RequestType_.error_
                      : ::RdsProtobuf::ServerMessage_AnswerMessage_Error::default_instance();
}
inline ::RdsProtobuf::ServerMessage_AnswerMessage_Error* ServerMessage_AnswerMessage::mutable_error() {
  if (!has_error()) {
    clear_RequestType();
    set_has_error();
    RequestType_.error_ = new ::RdsProtobuf::ServerMessage_AnswerMessage_Error;
  }
  return RequestType_.error_;
}
inline ::RdsProtobuf::ServerMessage_AnswerMessage_Error* ServerMessage_AnswerMessage::release_error() {
  if (has_error()) {
    clear_has_RequestType();
    ::RdsProtobuf::ServerMessage_AnswerMessage_Error* temp = RequestType_.error_;
    RequestType_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_AnswerMessage::set_allocated_error(::RdsProtobuf::ServerMessage_AnswerMessage_Error* error) {
  clear_RequestType();
  if (error) {
    set_has_error();
    RequestType_.error_ = error;
  }
}

// optional .RdsProtobuf.ServerMessage.AnswerMessage.Confirmation confirmation = 2;
inline bool ServerMessage_AnswerMessage::has_confirmation() const {
  return RequestType_case() == kConfirmation;
}
inline void ServerMessage_AnswerMessage::set_has_confirmation() {
  _oneof_case_[0] = kConfirmation;
}
inline void ServerMessage_AnswerMessage::clear_confirmation() {
  if (has_confirmation()) {
    delete RequestType_.confirmation_;
    clear_has_RequestType();
  }
}
inline const ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation& ServerMessage_AnswerMessage::confirmation() const {
  return has_confirmation() ? *RequestType_.confirmation_
                      : ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation::default_instance();
}
inline ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* ServerMessage_AnswerMessage::mutable_confirmation() {
  if (!has_confirmation()) {
    clear_RequestType();
    set_has_confirmation();
    RequestType_.confirmation_ = new ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation;
  }
  return RequestType_.confirmation_;
}
inline ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* ServerMessage_AnswerMessage::release_confirmation() {
  if (has_confirmation()) {
    clear_has_RequestType();
    ::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* temp = RequestType_.confirmation_;
    RequestType_.confirmation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage_AnswerMessage::set_allocated_confirmation(::RdsProtobuf::ServerMessage_AnswerMessage_Confirmation* confirmation) {
  clear_RequestType();
  if (confirmation) {
    set_has_confirmation();
    RequestType_.confirmation_ = confirmation;
  }
}

inline bool ServerMessage_AnswerMessage::has_RequestType() {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
inline void ServerMessage_AnswerMessage::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline ServerMessage_AnswerMessage::RequestTypeCase ServerMessage_AnswerMessage::RequestType_case() const {
  return ServerMessage_AnswerMessage::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// optional .RdsProtobuf.ServerMessage.CurrentMessage current = 1;
inline bool ServerMessage::has_current() const {
  return MessageType_case() == kCurrent;
}
inline void ServerMessage::set_has_current() {
  _oneof_case_[0] = kCurrent;
}
inline void ServerMessage::clear_current() {
  if (has_current()) {
    delete MessageType_.current_;
    clear_has_MessageType();
  }
}
inline const ::RdsProtobuf::ServerMessage_CurrentMessage& ServerMessage::current() const {
  return has_current() ? *MessageType_.current_
                      : ::RdsProtobuf::ServerMessage_CurrentMessage::default_instance();
}
inline ::RdsProtobuf::ServerMessage_CurrentMessage* ServerMessage::mutable_current() {
  if (!has_current()) {
    clear_MessageType();
    set_has_current();
    MessageType_.current_ = new ::RdsProtobuf::ServerMessage_CurrentMessage;
  }
  return MessageType_.current_;
}
inline ::RdsProtobuf::ServerMessage_CurrentMessage* ServerMessage::release_current() {
  if (has_current()) {
    clear_has_MessageType();
    ::RdsProtobuf::ServerMessage_CurrentMessage* temp = MessageType_.current_;
    MessageType_.current_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage::set_allocated_current(::RdsProtobuf::ServerMessage_CurrentMessage* current) {
  clear_MessageType();
  if (current) {
    set_has_current();
    MessageType_.current_ = current;
  }
}

// optional .RdsProtobuf.ServerMessage.DataMessage data = 2;
inline bool ServerMessage::has_data() const {
  return MessageType_case() == kData;
}
inline void ServerMessage::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void ServerMessage::clear_data() {
  if (has_data()) {
    delete MessageType_.data_;
    clear_has_MessageType();
  }
}
inline const ::RdsProtobuf::ServerMessage_DataMessage& ServerMessage::data() const {
  return has_data() ? *MessageType_.data_
                      : ::RdsProtobuf::ServerMessage_DataMessage::default_instance();
}
inline ::RdsProtobuf::ServerMessage_DataMessage* ServerMessage::mutable_data() {
  if (!has_data()) {
    clear_MessageType();
    set_has_data();
    MessageType_.data_ = new ::RdsProtobuf::ServerMessage_DataMessage;
  }
  return MessageType_.data_;
}
inline ::RdsProtobuf::ServerMessage_DataMessage* ServerMessage::release_data() {
  if (has_data()) {
    clear_has_MessageType();
    ::RdsProtobuf::ServerMessage_DataMessage* temp = MessageType_.data_;
    MessageType_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage::set_allocated_data(::RdsProtobuf::ServerMessage_DataMessage* data) {
  clear_MessageType();
  if (data) {
    set_has_data();
    MessageType_.data_ = data;
  }
}

// optional .RdsProtobuf.ServerMessage.AnswerMessage answer = 3;
inline bool ServerMessage::has_answer() const {
  return MessageType_case() == kAnswer;
}
inline void ServerMessage::set_has_answer() {
  _oneof_case_[0] = kAnswer;
}
inline void ServerMessage::clear_answer() {
  if (has_answer()) {
    delete MessageType_.answer_;
    clear_has_MessageType();
  }
}
inline const ::RdsProtobuf::ServerMessage_AnswerMessage& ServerMessage::answer() const {
  return has_answer() ? *MessageType_.answer_
                      : ::RdsProtobuf::ServerMessage_AnswerMessage::default_instance();
}
inline ::RdsProtobuf::ServerMessage_AnswerMessage* ServerMessage::mutable_answer() {
  if (!has_answer()) {
    clear_MessageType();
    set_has_answer();
    MessageType_.answer_ = new ::RdsProtobuf::ServerMessage_AnswerMessage;
  }
  return MessageType_.answer_;
}
inline ::RdsProtobuf::ServerMessage_AnswerMessage* ServerMessage::release_answer() {
  if (has_answer()) {
    clear_has_MessageType();
    ::RdsProtobuf::ServerMessage_AnswerMessage* temp = MessageType_.answer_;
    MessageType_.answer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMessage::set_allocated_answer(::RdsProtobuf::ServerMessage_AnswerMessage* answer) {
  clear_MessageType();
  if (answer) {
    set_has_answer();
    MessageType_.answer_ = answer;
  }
}

inline bool ServerMessage::has_MessageType() {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void ServerMessage::clear_has_MessageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline ServerMessage::MessageTypeCase ServerMessage::MessageType_case() const {
  return ServerMessage::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Packet

// optional .RdsProtobuf.ClientMessage from_client = 1;
inline bool Packet::has_from_client() const {
  return PacketType_case() == kFromClient;
}
inline void Packet::set_has_from_client() {
  _oneof_case_[0] = kFromClient;
}
inline void Packet::clear_from_client() {
  if (has_from_client()) {
    delete PacketType_.from_client_;
    clear_has_PacketType();
  }
}
inline const ::RdsProtobuf::ClientMessage& Packet::from_client() const {
  return has_from_client() ? *PacketType_.from_client_
                      : ::RdsProtobuf::ClientMessage::default_instance();
}
inline ::RdsProtobuf::ClientMessage* Packet::mutable_from_client() {
  if (!has_from_client()) {
    clear_PacketType();
    set_has_from_client();
    PacketType_.from_client_ = new ::RdsProtobuf::ClientMessage;
  }
  return PacketType_.from_client_;
}
inline ::RdsProtobuf::ClientMessage* Packet::release_from_client() {
  if (has_from_client()) {
    clear_has_PacketType();
    ::RdsProtobuf::ClientMessage* temp = PacketType_.from_client_;
    PacketType_.from_client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_from_client(::RdsProtobuf::ClientMessage* from_client) {
  clear_PacketType();
  if (from_client) {
    set_has_from_client();
    PacketType_.from_client_ = from_client;
  }
}

// optional .RdsProtobuf.ServerMessage from_server = 2;
inline bool Packet::has_from_server() const {
  return PacketType_case() == kFromServer;
}
inline void Packet::set_has_from_server() {
  _oneof_case_[0] = kFromServer;
}
inline void Packet::clear_from_server() {
  if (has_from_server()) {
    delete PacketType_.from_server_;
    clear_has_PacketType();
  }
}
inline const ::RdsProtobuf::ServerMessage& Packet::from_server() const {
  return has_from_server() ? *PacketType_.from_server_
                      : ::RdsProtobuf::ServerMessage::default_instance();
}
inline ::RdsProtobuf::ServerMessage* Packet::mutable_from_server() {
  if (!has_from_server()) {
    clear_PacketType();
    set_has_from_server();
    PacketType_.from_server_ = new ::RdsProtobuf::ServerMessage;
  }
  return PacketType_.from_server_;
}
inline ::RdsProtobuf::ServerMessage* Packet::release_from_server() {
  if (has_from_server()) {
    clear_has_PacketType();
    ::RdsProtobuf::ServerMessage* temp = PacketType_.from_server_;
    PacketType_.from_server_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_from_server(::RdsProtobuf::ServerMessage* from_server) {
  clear_PacketType();
  if (from_server) {
    set_has_from_server();
    PacketType_.from_server_ = from_server;
  }
}

inline bool Packet::has_PacketType() {
  return PacketType_case() != PACKETTYPE_NOT_SET;
}
inline void Packet::clear_has_PacketType() {
  _oneof_case_[0] = PACKETTYPE_NOT_SET;
}
inline Packet::PacketTypeCase Packet::PacketType_case() const {
  return Packet::PacketTypeCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace RdsProtobuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RdsPacket_2eproto__INCLUDED
