// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SolverPacket.proto

#ifndef PROTOBUF_SolverPacket_2eproto__INCLUDED
#define PROTOBUF_SolverPacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace SolverClient {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SolverPacket_2eproto();
void protobuf_AssignDesc_SolverPacket_2eproto();
void protobuf_ShutdownFile_SolverPacket_2eproto();

class Packet;
class Packet_ArgumentVariant;
class Packet_ArgumentVariant_BplaPosition;
class Packet_ArgumentVariant_BplaPosition_Coordinates;
class Packet_ArgumentVariant_SolverInput;
class Packet_ArgumentVariant_SolverAnswer;
class Packet_ArgumentVariant_SolverAnswer_Coordinates;
class Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy;
class Packet_ArgumentVariant_SolverAnswer_MotionEstimate;
class Packet_ArgumentVariant_SolverAnswer_CoordsEstimate;
class Packet_ArgumentVariant_SolverAnswer_Trajectory;
class Packet_ArgumentVariant_SolverAnswer_SingleMarks;
class Packet_ArgumentVariant_SolverAnswer_StateLines;
class Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine;
class Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon;
class Packet_ArgumentVariant_SolverAnswer_ErrorMessage;
class Packet_Command;

enum Actions {
  unknownAction = 0,
  sendSolverClientData = 1,
  sendSolverClientBla = 2,
  sendSolverClientResult = 3
};
bool Actions_IsValid(int value);
const Actions Actions_MIN = unknownAction;
const Actions Actions_MAX = sendSolverClientResult;
const int Actions_ARRAYSIZE = Actions_MAX + 1;

enum ResultOfCalculation {
  CALCULATED = 1,
  AN_ERROR_OCCURED = 2,
  NOT_ENOUGH_INPUT_DATA = 3,
  NO_SOLUTION = 4,
  CANT_IDENTIFY_REAL_TRAJECTORY = 5,
  TOO_LOW_ACCURACY_OF_INPUT_DATA = 6,
  TOO_FEW_INPUT_DATA = 7,
  TOO_LOW_ACCURACY_OF_SOLUTION = 8,
  TARGET_DOES_NOT_HIT_IN_AREA = 9,
  TARGET_DOES_NOT_HIT_IN_STROB = 10
};
bool ResultOfCalculation_IsValid(int value);
const ResultOfCalculation ResultOfCalculation_MIN = CALCULATED;
const ResultOfCalculation ResultOfCalculation_MAX = TARGET_DOES_NOT_HIT_IN_STROB;
const int ResultOfCalculation_ARRAYSIZE = ResultOfCalculation_MAX + 1;

enum SolverError {
  SOLVER_SETUP_ERROR = 1,
  SOLVER_INPUT_DATA_ERROR = 2,
  SOLVER_INTERNAL_ERROR = 3
};
bool SolverError_IsValid(int value);
const SolverError SolverError_MIN = SOLVER_SETUP_ERROR;
const SolverError SolverError_MAX = SOLVER_INTERNAL_ERROR;
const int SolverError_ARRAYSIZE = SolverError_MAX + 1;

enum EstimateQuality {
  GOOD_QUALITY = 1,
  BAD_QUALITY = 2,
  UNKNOWN_QUALITY = 3
};
bool EstimateQuality_IsValid(int value);
const EstimateQuality EstimateQuality_MIN = GOOD_QUALITY;
const EstimateQuality EstimateQuality_MAX = UNKNOWN_QUALITY;
const int EstimateQuality_ARRAYSIZE = EstimateQuality_MAX + 1;

enum StateOfMotion {
  MOVING = 1,
  STANDING = 2,
  UNKNOWN_STATE = 3
};
bool StateOfMotion_IsValid(int value);
const StateOfMotion StateOfMotion_MIN = MOVING;
const StateOfMotion StateOfMotion_MAX = UNKNOWN_STATE;
const int StateOfMotion_ARRAYSIZE = StateOfMotion_MAX + 1;

// ===================================================================

class Packet_ArgumentVariant_BplaPosition_Coordinates : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_BplaPosition_Coordinates();
  virtual ~Packet_ArgumentVariant_BplaPosition_Coordinates();

  Packet_ArgumentVariant_BplaPosition_Coordinates(const Packet_ArgumentVariant_BplaPosition_Coordinates& from);

  inline Packet_ArgumentVariant_BplaPosition_Coordinates& operator=(const Packet_ArgumentVariant_BplaPosition_Coordinates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_BplaPosition_Coordinates& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_BplaPosition_Coordinates* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_BplaPosition_Coordinates* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_BplaPosition_Coordinates* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_BplaPosition_Coordinates& from);
  void MergeFrom(const Packet_ArgumentVariant_BplaPosition_Coordinates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);

  // required double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);

  // required double alt = 3;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 3;
  inline double alt() const;
  inline void set_alt(double value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lat_;
  double lon_;
  double alt_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_BplaPosition_Coordinates* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_BplaPosition : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_BplaPosition();
  virtual ~Packet_ArgumentVariant_BplaPosition();

  Packet_ArgumentVariant_BplaPosition(const Packet_ArgumentVariant_BplaPosition& from);

  inline Packet_ArgumentVariant_BplaPosition& operator=(const Packet_ArgumentVariant_BplaPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_BplaPosition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_BplaPosition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_BplaPosition* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_BplaPosition* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_BplaPosition& from);
  void MergeFrom(const Packet_ArgumentVariant_BplaPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_BplaPosition_Coordinates Coordinates;

  // accessors -------------------------------------------------------

  // required uint32 bort_number = 1;
  inline bool has_bort_number() const;
  inline void clear_bort_number();
  static const int kBortNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 bort_number() const;
  inline void set_bort_number(::google::protobuf::uint32 value);

  // required int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required .SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates coordinates = 3;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 3;
  inline const ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates& coordinates() const;
  inline ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* mutable_coordinates();
  inline ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* release_coordinates();
  inline void set_allocated_coordinates(::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* coordinates);

  // required double speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline double speed() const;
  inline void set_speed(double value);

  // required double course = 5;
  inline bool has_course() const;
  inline void clear_course();
  static const int kCourseFieldNumber = 5;
  inline double course() const;
  inline void set_course(double value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.BplaPosition)
 private:
  inline void set_has_bort_number();
  inline void clear_has_bort_number();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_course();
  inline void clear_has_course();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_;
  ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* coordinates_;
  double speed_;
  double course_;
  ::google::protobuf::uint32 bort_number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_BplaPosition* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverInput : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverInput();
  virtual ~Packet_ArgumentVariant_SolverInput();

  Packet_ArgumentVariant_SolverInput(const Packet_ArgumentVariant_SolverInput& from);

  inline Packet_ArgumentVariant_SolverInput& operator=(const Packet_ArgumentVariant_SolverInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverInput& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverInput* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverInput* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverInput* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverInput& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double centerFrequency = 1;
  inline bool has_centerfrequency() const;
  inline void clear_centerfrequency();
  static const int kCenterFrequencyFieldNumber = 1;
  inline double centerfrequency() const;
  inline void set_centerfrequency(double value);

  // required int64 datetime = 2;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 2;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);

  // repeated double delays = 3;
  inline int delays_size() const;
  inline void clear_delays();
  static const int kDelaysFieldNumber = 3;
  inline double delays(int index) const;
  inline void set_delays(int index, double value);
  inline void add_delays(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      delays() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_delays();

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverInput)
 private:
  inline void set_has_centerfrequency();
  inline void clear_has_centerfrequency();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double centerfrequency_;
  ::google::protobuf::int64 datetime_;
  ::google::protobuf::RepeatedField< double > delays_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverInput* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_Coordinates : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_Coordinates();
  virtual ~Packet_ArgumentVariant_SolverAnswer_Coordinates();

  Packet_ArgumentVariant_SolverAnswer_Coordinates(const Packet_ArgumentVariant_SolverAnswer_Coordinates& from);

  inline Packet_ArgumentVariant_SolverAnswer_Coordinates& operator=(const Packet_ArgumentVariant_SolverAnswer_Coordinates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_Coordinates& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_Coordinates* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_Coordinates* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_Coordinates* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_Coordinates& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_Coordinates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);

  // required double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);

  // required double alt = 3;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 3;
  inline double alt() const;
  inline void set_alt(double value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lat_;
  double lon_;
  double alt_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_Coordinates* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy();
  virtual ~Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy();

  Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy(const Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& from);

  inline Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& operator=(const Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat_acc = 1;
  inline bool has_lat_acc() const;
  inline void clear_lat_acc();
  static const int kLatAccFieldNumber = 1;
  inline double lat_acc() const;
  inline void set_lat_acc(double value);

  // required double lon_acc = 2;
  inline bool has_lon_acc() const;
  inline void clear_lon_acc();
  static const int kLonAccFieldNumber = 2;
  inline double lon_acc() const;
  inline void set_lon_acc(double value);

  // required double alt_acc = 3;
  inline bool has_alt_acc() const;
  inline void clear_alt_acc();
  static const int kAltAccFieldNumber = 3;
  inline double alt_acc() const;
  inline void set_alt_acc(double value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy)
 private:
  inline void set_has_lat_acc();
  inline void clear_has_lat_acc();
  inline void set_has_lon_acc();
  inline void clear_has_lon_acc();
  inline void set_has_alt_acc();
  inline void clear_has_alt_acc();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lat_acc_;
  double lon_acc_;
  double alt_acc_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_MotionEstimate : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_MotionEstimate();
  virtual ~Packet_ArgumentVariant_SolverAnswer_MotionEstimate();

  Packet_ArgumentVariant_SolverAnswer_MotionEstimate(const Packet_ArgumentVariant_SolverAnswer_MotionEstimate& from);

  inline Packet_ArgumentVariant_SolverAnswer_MotionEstimate& operator=(const Packet_ArgumentVariant_SolverAnswer_MotionEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_MotionEstimate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_MotionEstimate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_MotionEstimate* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_MotionEstimate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_MotionEstimate& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_MotionEstimate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 datetime = 1;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 1;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);

  // required .SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates coordinates = 2;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates& coordinates() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* mutable_coordinates();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* release_coordinates();
  inline void set_allocated_coordinates(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* coordinates);

  // required .SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy coordinates_acc = 3;
  inline bool has_coordinates_acc() const;
  inline void clear_coordinates_acc();
  static const int kCoordinatesAccFieldNumber = 3;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& coordinates_acc() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* mutable_coordinates_acc();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* release_coordinates_acc();
  inline void set_allocated_coordinates_acc(::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* coordinates_acc);

  // required double targetSpeed = 4;
  inline bool has_targetspeed() const;
  inline void clear_targetspeed();
  static const int kTargetSpeedFieldNumber = 4;
  inline double targetspeed() const;
  inline void set_targetspeed(double value);

  // required double targetSpeed_acc = 5;
  inline bool has_targetspeed_acc() const;
  inline void clear_targetspeed_acc();
  static const int kTargetSpeedAccFieldNumber = 5;
  inline double targetspeed_acc() const;
  inline void set_targetspeed_acc(double value);

  // required double relativeBearing = 6;
  inline bool has_relativebearing() const;
  inline void clear_relativebearing();
  static const int kRelativeBearingFieldNumber = 6;
  inline double relativebearing() const;
  inline void set_relativebearing(double value);

  // required .SolverClient.EstimateQuality quality = 7;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 7;
  inline ::SolverClient::EstimateQuality quality() const;
  inline void set_quality(::SolverClient::EstimateQuality value);

  // required .SolverClient.StateOfMotion state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::SolverClient::StateOfMotion state() const;
  inline void set_state(::SolverClient::StateOfMotion value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate)
 private:
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();
  inline void set_has_coordinates_acc();
  inline void clear_has_coordinates_acc();
  inline void set_has_targetspeed();
  inline void clear_has_targetspeed();
  inline void set_has_targetspeed_acc();
  inline void clear_has_targetspeed_acc();
  inline void set_has_relativebearing();
  inline void clear_has_relativebearing();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 datetime_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* coordinates_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* coordinates_acc_;
  double targetspeed_;
  double targetspeed_acc_;
  double relativebearing_;
  int quality_;
  int state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_MotionEstimate* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_CoordsEstimate : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_CoordsEstimate();
  virtual ~Packet_ArgumentVariant_SolverAnswer_CoordsEstimate();

  Packet_ArgumentVariant_SolverAnswer_CoordsEstimate(const Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& from);

  inline Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& operator=(const Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 datetime = 1;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 1;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);

  // required .SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates coordinates = 2;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates& coordinates() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* mutable_coordinates();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* release_coordinates();
  inline void set_allocated_coordinates(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* coordinates);

  // required .SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy coordinates_acc = 3;
  inline bool has_coordinates_acc() const;
  inline void clear_coordinates_acc();
  static const int kCoordinatesAccFieldNumber = 3;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& coordinates_acc() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* mutable_coordinates_acc();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* release_coordinates_acc();
  inline void set_allocated_coordinates_acc(::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* coordinates_acc);

  // required .SolverClient.EstimateQuality quality = 4;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 4;
  inline ::SolverClient::EstimateQuality quality() const;
  inline void set_quality(::SolverClient::EstimateQuality value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate)
 private:
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();
  inline void set_has_coordinates_acc();
  inline void clear_has_coordinates_acc();
  inline void set_has_quality();
  inline void clear_has_quality();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 datetime_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* coordinates_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* coordinates_acc_;
  int quality_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_Trajectory : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_Trajectory();
  virtual ~Packet_ArgumentVariant_SolverAnswer_Trajectory();

  Packet_ArgumentVariant_SolverAnswer_Trajectory(const Packet_ArgumentVariant_SolverAnswer_Trajectory& from);

  inline Packet_ArgumentVariant_SolverAnswer_Trajectory& operator=(const Packet_ArgumentVariant_SolverAnswer_Trajectory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_Trajectory& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_Trajectory* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_Trajectory* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_Trajectory* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_Trajectory& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_Trajectory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SolverClient.ResultOfCalculation result_of_calculation = 1;
  inline bool has_result_of_calculation() const;
  inline void clear_result_of_calculation();
  static const int kResultOfCalculationFieldNumber = 1;
  inline ::SolverClient::ResultOfCalculation result_of_calculation() const;
  inline void set_result_of_calculation(::SolverClient::ResultOfCalculation value);

  // repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate motionEstimate = 2;
  inline int motionestimate_size() const;
  inline void clear_motionestimate();
  static const int kMotionEstimateFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate& motionestimate(int index) const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate* mutable_motionestimate(int index);
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate* add_motionestimate();
  inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate >&
      motionestimate() const;
  inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate >*
      mutable_motionestimate();

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory)
 private:
  inline void set_has_result_of_calculation();
  inline void clear_has_result_of_calculation();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate > motionestimate_;
  int result_of_calculation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_Trajectory* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_SingleMarks : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_SingleMarks();
  virtual ~Packet_ArgumentVariant_SolverAnswer_SingleMarks();

  Packet_ArgumentVariant_SolverAnswer_SingleMarks(const Packet_ArgumentVariant_SolverAnswer_SingleMarks& from);

  inline Packet_ArgumentVariant_SolverAnswer_SingleMarks& operator=(const Packet_ArgumentVariant_SolverAnswer_SingleMarks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_SingleMarks& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_SingleMarks* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_SingleMarks* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_SingleMarks* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_SingleMarks& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_SingleMarks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SolverClient.ResultOfCalculation result_of_calculation = 1;
  inline bool has_result_of_calculation() const;
  inline void clear_result_of_calculation();
  static const int kResultOfCalculationFieldNumber = 1;
  inline ::SolverClient::ResultOfCalculation result_of_calculation() const;
  inline void set_result_of_calculation(::SolverClient::ResultOfCalculation value);

  // repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate coordsEstimate = 2;
  inline int coordsestimate_size() const;
  inline void clear_coordsestimate();
  static const int kCoordsEstimateFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& coordsestimate(int index) const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* mutable_coordsestimate(int index);
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* add_coordsestimate();
  inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate >&
      coordsestimate() const;
  inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate >*
      mutable_coordsestimate();

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks)
 private:
  inline void set_has_result_of_calculation();
  inline void clear_has_result_of_calculation();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate > coordsestimate_;
  int result_of_calculation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_SingleMarks* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon();
  virtual ~Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon();

  Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& from);

  inline Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& operator=(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);

  // required double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lat_;
  double lon_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine();
  virtual ~Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine();

  Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& from);

  inline Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& operator=(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon LatLon;

  // accessors -------------------------------------------------------

  // repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon point = 1;
  inline int point_size() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& point(int index) const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* mutable_point(int index);
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* add_point();
  inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon >&
      point() const;
  inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon >*
      mutable_point();

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon > point_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_StateLines : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_StateLines();
  virtual ~Packet_ArgumentVariant_SolverAnswer_StateLines();

  Packet_ArgumentVariant_SolverAnswer_StateLines(const Packet_ArgumentVariant_SolverAnswer_StateLines& from);

  inline Packet_ArgumentVariant_SolverAnswer_StateLines& operator=(const Packet_ArgumentVariant_SolverAnswer_StateLines& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_StateLines& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_StateLines* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_StateLines* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_StateLines* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_StateLines& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_StateLines& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine StateLine;

  // accessors -------------------------------------------------------

  // required .SolverClient.ResultOfCalculation result_of_calculation = 1;
  inline bool has_result_of_calculation() const;
  inline void clear_result_of_calculation();
  static const int kResultOfCalculationFieldNumber = 1;
  inline ::SolverClient::ResultOfCalculation result_of_calculation() const;
  inline void set_result_of_calculation(::SolverClient::ResultOfCalculation value);

  // required int64 datetime = 2;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 2;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);

  // repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine stateLine = 3;
  inline int stateline_size() const;
  inline void clear_stateline();
  static const int kStateLineFieldNumber = 3;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& stateline(int index) const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* mutable_stateline(int index);
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* add_stateline();
  inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine >&
      stateline() const;
  inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine >*
      mutable_stateline();

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines)
 private:
  inline void set_has_result_of_calculation();
  inline void clear_has_result_of_calculation();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 datetime_;
  ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine > stateline_;
  int result_of_calculation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_StateLines* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer_ErrorMessage : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer_ErrorMessage();
  virtual ~Packet_ArgumentVariant_SolverAnswer_ErrorMessage();

  Packet_ArgumentVariant_SolverAnswer_ErrorMessage(const Packet_ArgumentVariant_SolverAnswer_ErrorMessage& from);

  inline Packet_ArgumentVariant_SolverAnswer_ErrorMessage& operator=(const Packet_ArgumentVariant_SolverAnswer_ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer_ErrorMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer_ErrorMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer_ErrorMessage* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer_ErrorMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer_ErrorMessage& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer_ErrorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SolverClient.SolverError errorType = 1;
  inline bool has_errortype() const;
  inline void clear_errortype();
  static const int kErrorTypeFieldNumber = 1;
  inline ::SolverClient::SolverError errortype() const;
  inline void set_errortype(::SolverClient::SolverError value);

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage)
 private:
  inline void set_has_errortype();
  inline void clear_has_errortype();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  int errortype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer_ErrorMessage* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverAnswer : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverAnswer();
  virtual ~Packet_ArgumentVariant_SolverAnswer();

  Packet_ArgumentVariant_SolverAnswer(const Packet_ArgumentVariant_SolverAnswer& from);

  inline Packet_ArgumentVariant_SolverAnswer& operator=(const Packet_ArgumentVariant_SolverAnswer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverAnswer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverAnswer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverAnswer* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverAnswer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverAnswer& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverAnswer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_SolverAnswer_Coordinates Coordinates;
  typedef Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy CoordinatesAccuracy;
  typedef Packet_ArgumentVariant_SolverAnswer_MotionEstimate MotionEstimate;
  typedef Packet_ArgumentVariant_SolverAnswer_CoordsEstimate CoordsEstimate;
  typedef Packet_ArgumentVariant_SolverAnswer_Trajectory Trajectory;
  typedef Packet_ArgumentVariant_SolverAnswer_SingleMarks SingleMarks;
  typedef Packet_ArgumentVariant_SolverAnswer_StateLines StateLines;
  typedef Packet_ArgumentVariant_SolverAnswer_ErrorMessage ErrorMessage;

  // accessors -------------------------------------------------------

  // required uint32 TargetID = 1;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 targetid() const;
  inline void set_targetid(::google::protobuf::uint32 value);

  // optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory auto_trajectory = 2;
  inline bool has_auto_trajectory() const;
  inline void clear_auto_trajectory();
  static const int kAutoTrajectoryFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory& auto_trajectory() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* mutable_auto_trajectory();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* release_auto_trajectory();
  inline void set_allocated_auto_trajectory(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* auto_trajectory);

  // optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory manual_trajectory = 3;
  inline bool has_manual_trajectory() const;
  inline void clear_manual_trajectory();
  static const int kManualTrajectoryFieldNumber = 3;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory& manual_trajectory() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* mutable_manual_trajectory();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* release_manual_trajectory();
  inline void set_allocated_manual_trajectory(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* manual_trajectory);

  // optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks singleMarks = 4;
  inline bool has_singlemarks() const;
  inline void clear_singlemarks();
  static const int kSingleMarksFieldNumber = 4;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks& singlemarks() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* mutable_singlemarks();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* release_singlemarks();
  inline void set_allocated_singlemarks(::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* singlemarks);

  // optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines stateLines = 5;
  inline bool has_statelines() const;
  inline void clear_statelines();
  static const int kStateLinesFieldNumber = 5;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines& statelines() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* mutable_statelines();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* release_statelines();
  inline void set_allocated_statelines(::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* statelines);

  // optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage errorMessage = 6;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 6;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage& errormessage() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* mutable_errormessage();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* release_errormessage();
  inline void set_allocated_errormessage(::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* errormessage);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant.SolverAnswer)
 private:
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_auto_trajectory();
  inline void clear_has_auto_trajectory();
  inline void set_has_manual_trajectory();
  inline void clear_has_manual_trajectory();
  inline void set_has_singlemarks();
  inline void clear_has_singlemarks();
  inline void set_has_statelines();
  inline void clear_has_statelines();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* auto_trajectory_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* manual_trajectory_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* singlemarks_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* statelines_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* errormessage_;
  ::google::protobuf::uint32 targetid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverAnswer* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant();
  virtual ~Packet_ArgumentVariant();

  Packet_ArgumentVariant(const Packet_ArgumentVariant& from);

  inline Packet_ArgumentVariant& operator=(const Packet_ArgumentVariant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant& from);
  void MergeFrom(const Packet_ArgumentVariant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_BplaPosition BplaPosition;
  typedef Packet_ArgumentVariant_SolverInput SolverInput;
  typedef Packet_ArgumentVariant_SolverAnswer SolverAnswer;

  // accessors -------------------------------------------------------

  // optional .SolverClient.Packet.ArgumentVariant.BplaPosition bplaPoisition = 1;
  inline bool has_bplapoisition() const;
  inline void clear_bplapoisition();
  static const int kBplaPoisitionFieldNumber = 1;
  inline const ::SolverClient::Packet_ArgumentVariant_BplaPosition& bplapoisition() const;
  inline ::SolverClient::Packet_ArgumentVariant_BplaPosition* mutable_bplapoisition();
  inline ::SolverClient::Packet_ArgumentVariant_BplaPosition* release_bplapoisition();
  inline void set_allocated_bplapoisition(::SolverClient::Packet_ArgumentVariant_BplaPosition* bplapoisition);

  // optional .SolverClient.Packet.ArgumentVariant.SolverInput solverInput = 2;
  inline bool has_solverinput() const;
  inline void clear_solverinput();
  static const int kSolverInputFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverInput& solverinput() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverInput* mutable_solverinput();
  inline ::SolverClient::Packet_ArgumentVariant_SolverInput* release_solverinput();
  inline void set_allocated_solverinput(::SolverClient::Packet_ArgumentVariant_SolverInput* solverinput);

  // optional .SolverClient.Packet.ArgumentVariant.SolverAnswer solverAnswer = 3;
  inline bool has_solveranswer() const;
  inline void clear_solveranswer();
  static const int kSolverAnswerFieldNumber = 3;
  inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer& solveranswer() const;
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer* mutable_solveranswer();
  inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer* release_solveranswer();
  inline void set_allocated_solveranswer(::SolverClient::Packet_ArgumentVariant_SolverAnswer* solveranswer);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.ArgumentVariant)
 private:
  inline void set_has_bplapoisition();
  inline void clear_has_bplapoisition();
  inline void set_has_solverinput();
  inline void clear_has_solverinput();
  inline void set_has_solveranswer();
  inline void clear_has_solveranswer();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SolverClient::Packet_ArgumentVariant_BplaPosition* bplapoisition_;
  ::SolverClient::Packet_ArgumentVariant_SolverInput* solverinput_;
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer* solveranswer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Command : public ::google::protobuf::MessageLite {
 public:
  Packet_Command();
  virtual ~Packet_Command();

  Packet_Command(const Packet_Command& from);

  inline Packet_Command& operator=(const Packet_Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_Command& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_Command* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_Command* other);

  // implements Message ----------------------------------------------

  Packet_Command* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_Command& from);
  void MergeFrom(const Packet_Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SolverClient.Actions action = 1 [default = unknownAction];
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::SolverClient::Actions action() const;
  inline void set_action(::SolverClient::Actions value);

  // optional .SolverClient.Packet.ArgumentVariant arguments = 2;
  inline bool has_arguments() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 2;
  inline const ::SolverClient::Packet_ArgumentVariant& arguments() const;
  inline ::SolverClient::Packet_ArgumentVariant* mutable_arguments();
  inline ::SolverClient::Packet_ArgumentVariant* release_arguments();
  inline void set_allocated_arguments(::SolverClient::Packet_ArgumentVariant* arguments);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet.Command)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_arguments();
  inline void clear_has_arguments();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SolverClient::Packet_ArgumentVariant* arguments_;
  int action_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_Command* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::MessageLite {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  Packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant ArgumentVariant;
  typedef Packet_Command Command;

  // accessors -------------------------------------------------------

  // required .SolverClient.Packet.Command command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::SolverClient::Packet_Command& command() const;
  inline ::SolverClient::Packet_Command* mutable_command();
  inline ::SolverClient::Packet_Command* release_command();
  inline void set_allocated_command(::SolverClient::Packet_Command* command);

  // @@protoc_insertion_point(class_scope:SolverClient.Packet)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SolverClient::Packet_Command* command_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SolverPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SolverPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_SolverPacket_2eproto();
  friend void protobuf_ShutdownFile_SolverPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// ===================================================================


// ===================================================================

// Packet_ArgumentVariant_BplaPosition_Coordinates

// required double lat = 1;
inline bool Packet_ArgumentVariant_BplaPosition_Coordinates::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double Packet_ArgumentVariant_BplaPosition_Coordinates::lat() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates.lat)
  return lat_;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates.lat)
}

// required double lon = 2;
inline bool Packet_ArgumentVariant_BplaPosition_Coordinates::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double Packet_ArgumentVariant_BplaPosition_Coordinates::lon() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates.lon)
  return lon_;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates.lon)
}

// required double alt = 3;
inline bool Packet_ArgumentVariant_BplaPosition_Coordinates::has_alt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::set_has_alt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::clear_has_alt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline double Packet_ArgumentVariant_BplaPosition_Coordinates::alt() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates.alt)
  return alt_;
}
inline void Packet_ArgumentVariant_BplaPosition_Coordinates::set_alt(double value) {
  set_has_alt();
  alt_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates.alt)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_BplaPosition

// required uint32 bort_number = 1;
inline bool Packet_ArgumentVariant_BplaPosition::has_bort_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition::set_has_bort_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_has_bort_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_bort_number() {
  bort_number_ = 0u;
  clear_has_bort_number();
}
inline ::google::protobuf::uint32 Packet_ArgumentVariant_BplaPosition::bort_number() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.bort_number)
  return bort_number_;
}
inline void Packet_ArgumentVariant_BplaPosition::set_bort_number(::google::protobuf::uint32 value) {
  set_has_bort_number();
  bort_number_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.bort_number)
}

// required int64 time = 2;
inline bool Packet_ArgumentVariant_BplaPosition::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Packet_ArgumentVariant_BplaPosition::time() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.time)
  return time_;
}
inline void Packet_ArgumentVariant_BplaPosition::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.time)
}

// required .SolverClient.Packet.ArgumentVariant.BplaPosition.Coordinates coordinates = 3;
inline bool Packet_ArgumentVariant_BplaPosition::has_coordinates() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition::set_has_coordinates() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates::Clear();
  clear_has_coordinates();
}
inline const ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates& Packet_ArgumentVariant_BplaPosition::coordinates() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.coordinates)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinates_ != NULL ? *coordinates_ : *default_instance().coordinates_;
#else
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* Packet_ArgumentVariant_BplaPosition::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.BplaPosition.coordinates)
  return coordinates_;
}
inline ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* Packet_ArgumentVariant_BplaPosition::release_coordinates() {
  clear_has_coordinates();
  ::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_BplaPosition::set_allocated_coordinates(::SolverClient::Packet_ArgumentVariant_BplaPosition_Coordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.BplaPosition.coordinates)
}

// required double speed = 4;
inline bool Packet_ArgumentVariant_BplaPosition::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Packet_ArgumentVariant_BplaPosition::speed() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.speed)
  return speed_;
}
inline void Packet_ArgumentVariant_BplaPosition::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.speed)
}

// required double course = 5;
inline bool Packet_ArgumentVariant_BplaPosition::has_course() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ArgumentVariant_BplaPosition::set_has_course() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_has_course() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ArgumentVariant_BplaPosition::clear_course() {
  course_ = 0;
  clear_has_course();
}
inline double Packet_ArgumentVariant_BplaPosition::course() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.BplaPosition.course)
  return course_;
}
inline void Packet_ArgumentVariant_BplaPosition::set_course(double value) {
  set_has_course();
  course_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.BplaPosition.course)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverInput

// required double centerFrequency = 1;
inline bool Packet_ArgumentVariant_SolverInput::has_centerfrequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverInput::set_has_centerfrequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverInput::clear_has_centerfrequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverInput::clear_centerfrequency() {
  centerfrequency_ = 0;
  clear_has_centerfrequency();
}
inline double Packet_ArgumentVariant_SolverInput::centerfrequency() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverInput.centerFrequency)
  return centerfrequency_;
}
inline void Packet_ArgumentVariant_SolverInput::set_centerfrequency(double value) {
  set_has_centerfrequency();
  centerfrequency_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverInput.centerFrequency)
}

// required int64 datetime = 2;
inline bool Packet_ArgumentVariant_SolverInput::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverInput::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverInput::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverInput::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 Packet_ArgumentVariant_SolverInput::datetime() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverInput.datetime)
  return datetime_;
}
inline void Packet_ArgumentVariant_SolverInput::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverInput.datetime)
}

// repeated double delays = 3;
inline int Packet_ArgumentVariant_SolverInput::delays_size() const {
  return delays_.size();
}
inline void Packet_ArgumentVariant_SolverInput::clear_delays() {
  delays_.Clear();
}
inline double Packet_ArgumentVariant_SolverInput::delays(int index) const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverInput.delays)
  return delays_.Get(index);
}
inline void Packet_ArgumentVariant_SolverInput::set_delays(int index, double value) {
  delays_.Set(index, value);
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverInput.delays)
}
inline void Packet_ArgumentVariant_SolverInput::add_delays(double value) {
  delays_.Add(value);
  // @@protoc_insertion_point(field_add:SolverClient.Packet.ArgumentVariant.SolverInput.delays)
}
inline const ::google::protobuf::RepeatedField< double >&
Packet_ArgumentVariant_SolverInput::delays() const {
  // @@protoc_insertion_point(field_list:SolverClient.Packet.ArgumentVariant.SolverInput.delays)
  return delays_;
}
inline ::google::protobuf::RepeatedField< double >*
Packet_ArgumentVariant_SolverInput::mutable_delays() {
  // @@protoc_insertion_point(field_mutable_list:SolverClient.Packet.ArgumentVariant.SolverInput.delays)
  return &delays_;
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_Coordinates

// required double lat = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_Coordinates::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double Packet_ArgumentVariant_SolverAnswer_Coordinates::lat() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates.lat)
  return lat_;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates.lat)
}

// required double lon = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_Coordinates::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double Packet_ArgumentVariant_SolverAnswer_Coordinates::lon() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates.lon)
  return lon_;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates.lon)
}

// required double alt = 3;
inline bool Packet_ArgumentVariant_SolverAnswer_Coordinates::has_alt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::set_has_alt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::clear_has_alt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline double Packet_ArgumentVariant_SolverAnswer_Coordinates::alt() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates.alt)
  return alt_;
}
inline void Packet_ArgumentVariant_SolverAnswer_Coordinates::set_alt(double value) {
  set_has_alt();
  alt_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates.alt)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy

// required double lat_acc = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::has_lat_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::set_has_lat_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::clear_has_lat_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::clear_lat_acc() {
  lat_acc_ = 0;
  clear_has_lat_acc();
}
inline double Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::lat_acc() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy.lat_acc)
  return lat_acc_;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::set_lat_acc(double value) {
  set_has_lat_acc();
  lat_acc_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy.lat_acc)
}

// required double lon_acc = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::has_lon_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::set_has_lon_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::clear_has_lon_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::clear_lon_acc() {
  lon_acc_ = 0;
  clear_has_lon_acc();
}
inline double Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::lon_acc() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy.lon_acc)
  return lon_acc_;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::set_lon_acc(double value) {
  set_has_lon_acc();
  lon_acc_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy.lon_acc)
}

// required double alt_acc = 3;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::has_alt_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::set_has_alt_acc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::clear_has_alt_acc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::clear_alt_acc() {
  alt_acc_ = 0;
  clear_has_alt_acc();
}
inline double Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::alt_acc() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy.alt_acc)
  return alt_acc_;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::set_alt_acc(double value) {
  set_has_alt_acc();
  alt_acc_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy.alt_acc)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_MotionEstimate

// required int64 datetime = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 Packet_ArgumentVariant_SolverAnswer_MotionEstimate::datetime() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.datetime)
  return datetime_;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.datetime)
}

// required .SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates coordinates = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_coordinates() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_coordinates() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates::Clear();
  clear_has_coordinates();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates& Packet_ArgumentVariant_SolverAnswer_MotionEstimate::coordinates() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.coordinates)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinates_ != NULL ? *coordinates_ : *default_instance().coordinates_;
#else
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* Packet_ArgumentVariant_SolverAnswer_MotionEstimate::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.coordinates)
  return coordinates_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* Packet_ArgumentVariant_SolverAnswer_MotionEstimate::release_coordinates() {
  clear_has_coordinates();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_allocated_coordinates(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.coordinates)
}

// required .SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy coordinates_acc = 3;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_coordinates_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_coordinates_acc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_coordinates_acc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_coordinates_acc() {
  if (coordinates_acc_ != NULL) coordinates_acc_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::Clear();
  clear_has_coordinates_acc();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& Packet_ArgumentVariant_SolverAnswer_MotionEstimate::coordinates_acc() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.coordinates_acc)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinates_acc_ != NULL ? *coordinates_acc_ : *default_instance().coordinates_acc_;
#else
  return coordinates_acc_ != NULL ? *coordinates_acc_ : *default_instance_->coordinates_acc_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* Packet_ArgumentVariant_SolverAnswer_MotionEstimate::mutable_coordinates_acc() {
  set_has_coordinates_acc();
  if (coordinates_acc_ == NULL) coordinates_acc_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.coordinates_acc)
  return coordinates_acc_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* Packet_ArgumentVariant_SolverAnswer_MotionEstimate::release_coordinates_acc() {
  clear_has_coordinates_acc();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* temp = coordinates_acc_;
  coordinates_acc_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_allocated_coordinates_acc(::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* coordinates_acc) {
  delete coordinates_acc_;
  coordinates_acc_ = coordinates_acc;
  if (coordinates_acc) {
    set_has_coordinates_acc();
  } else {
    clear_has_coordinates_acc();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.coordinates_acc)
}

// required double targetSpeed = 4;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_targetspeed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_targetspeed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_targetspeed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_targetspeed() {
  targetspeed_ = 0;
  clear_has_targetspeed();
}
inline double Packet_ArgumentVariant_SolverAnswer_MotionEstimate::targetspeed() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.targetSpeed)
  return targetspeed_;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_targetspeed(double value) {
  set_has_targetspeed();
  targetspeed_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.targetSpeed)
}

// required double targetSpeed_acc = 5;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_targetspeed_acc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_targetspeed_acc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_targetspeed_acc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_targetspeed_acc() {
  targetspeed_acc_ = 0;
  clear_has_targetspeed_acc();
}
inline double Packet_ArgumentVariant_SolverAnswer_MotionEstimate::targetspeed_acc() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.targetSpeed_acc)
  return targetspeed_acc_;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_targetspeed_acc(double value) {
  set_has_targetspeed_acc();
  targetspeed_acc_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.targetSpeed_acc)
}

// required double relativeBearing = 6;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_relativebearing() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_relativebearing() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_relativebearing() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_relativebearing() {
  relativebearing_ = 0;
  clear_has_relativebearing();
}
inline double Packet_ArgumentVariant_SolverAnswer_MotionEstimate::relativebearing() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.relativeBearing)
  return relativebearing_;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_relativebearing(double value) {
  set_has_relativebearing();
  relativebearing_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.relativeBearing)
}

// required .SolverClient.EstimateQuality quality = 7;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_quality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_quality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_quality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_quality() {
  quality_ = 1;
  clear_has_quality();
}
inline ::SolverClient::EstimateQuality Packet_ArgumentVariant_SolverAnswer_MotionEstimate::quality() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.quality)
  return static_cast< ::SolverClient::EstimateQuality >(quality_);
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_quality(::SolverClient::EstimateQuality value) {
  assert(::SolverClient::EstimateQuality_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.quality)
}

// required .SolverClient.StateOfMotion state = 8;
inline bool Packet_ArgumentVariant_SolverAnswer_MotionEstimate::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::SolverClient::StateOfMotion Packet_ArgumentVariant_SolverAnswer_MotionEstimate::state() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.state)
  return static_cast< ::SolverClient::StateOfMotion >(state_);
}
inline void Packet_ArgumentVariant_SolverAnswer_MotionEstimate::set_state(::SolverClient::StateOfMotion value) {
  assert(::SolverClient::StateOfMotion_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate.state)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_CoordsEstimate

// required int64 datetime = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::has_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_has_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::datetime() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.datetime)
  return datetime_;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.datetime)
}

// required .SolverClient.Packet.ArgumentVariant.SolverAnswer.Coordinates coordinates = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::has_coordinates() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_has_coordinates() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates::Clear();
  clear_has_coordinates();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates& Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::coordinates() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.coordinates)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinates_ != NULL ? *coordinates_ : *default_instance().coordinates_;
#else
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.coordinates)
  return coordinates_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::release_coordinates() {
  clear_has_coordinates();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_allocated_coordinates(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Coordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.coordinates)
}

// required .SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordinatesAccuracy coordinates_acc = 3;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::has_coordinates_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_has_coordinates_acc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_has_coordinates_acc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_coordinates_acc() {
  if (coordinates_acc_ != NULL) coordinates_acc_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy::Clear();
  clear_has_coordinates_acc();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy& Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::coordinates_acc() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.coordinates_acc)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinates_acc_ != NULL ? *coordinates_acc_ : *default_instance().coordinates_acc_;
#else
  return coordinates_acc_ != NULL ? *coordinates_acc_ : *default_instance_->coordinates_acc_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::mutable_coordinates_acc() {
  set_has_coordinates_acc();
  if (coordinates_acc_ == NULL) coordinates_acc_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.coordinates_acc)
  return coordinates_acc_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::release_coordinates_acc() {
  clear_has_coordinates_acc();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* temp = coordinates_acc_;
  coordinates_acc_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_allocated_coordinates_acc(::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordinatesAccuracy* coordinates_acc) {
  delete coordinates_acc_;
  coordinates_acc_ = coordinates_acc;
  if (coordinates_acc) {
    set_has_coordinates_acc();
  } else {
    clear_has_coordinates_acc();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.coordinates_acc)
}

// required .SolverClient.EstimateQuality quality = 4;
inline bool Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::has_quality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_has_quality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_has_quality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::clear_quality() {
  quality_ = 1;
  clear_has_quality();
}
inline ::SolverClient::EstimateQuality Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::quality() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.quality)
  return static_cast< ::SolverClient::EstimateQuality >(quality_);
}
inline void Packet_ArgumentVariant_SolverAnswer_CoordsEstimate::set_quality(::SolverClient::EstimateQuality value) {
  assert(::SolverClient::EstimateQuality_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate.quality)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_Trajectory

// required .SolverClient.ResultOfCalculation result_of_calculation = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_Trajectory::has_result_of_calculation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_Trajectory::set_has_result_of_calculation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Trajectory::clear_has_result_of_calculation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_Trajectory::clear_result_of_calculation() {
  result_of_calculation_ = 1;
  clear_has_result_of_calculation();
}
inline ::SolverClient::ResultOfCalculation Packet_ArgumentVariant_SolverAnswer_Trajectory::result_of_calculation() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.result_of_calculation)
  return static_cast< ::SolverClient::ResultOfCalculation >(result_of_calculation_);
}
inline void Packet_ArgumentVariant_SolverAnswer_Trajectory::set_result_of_calculation(::SolverClient::ResultOfCalculation value) {
  assert(::SolverClient::ResultOfCalculation_IsValid(value));
  set_has_result_of_calculation();
  result_of_calculation_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.result_of_calculation)
}

// repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.MotionEstimate motionEstimate = 2;
inline int Packet_ArgumentVariant_SolverAnswer_Trajectory::motionestimate_size() const {
  return motionestimate_.size();
}
inline void Packet_ArgumentVariant_SolverAnswer_Trajectory::clear_motionestimate() {
  motionestimate_.Clear();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate& Packet_ArgumentVariant_SolverAnswer_Trajectory::motionestimate(int index) const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.motionEstimate)
  return motionestimate_.Get(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate* Packet_ArgumentVariant_SolverAnswer_Trajectory::mutable_motionestimate(int index) {
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.motionEstimate)
  return motionestimate_.Mutable(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate* Packet_ArgumentVariant_SolverAnswer_Trajectory::add_motionestimate() {
  // @@protoc_insertion_point(field_add:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.motionEstimate)
  return motionestimate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate >&
Packet_ArgumentVariant_SolverAnswer_Trajectory::motionestimate() const {
  // @@protoc_insertion_point(field_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.motionEstimate)
  return motionestimate_;
}
inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_MotionEstimate >*
Packet_ArgumentVariant_SolverAnswer_Trajectory::mutable_motionestimate() {
  // @@protoc_insertion_point(field_mutable_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory.motionEstimate)
  return &motionestimate_;
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_SingleMarks

// required .SolverClient.ResultOfCalculation result_of_calculation = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_SingleMarks::has_result_of_calculation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_SingleMarks::set_has_result_of_calculation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_SingleMarks::clear_has_result_of_calculation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_SingleMarks::clear_result_of_calculation() {
  result_of_calculation_ = 1;
  clear_has_result_of_calculation();
}
inline ::SolverClient::ResultOfCalculation Packet_ArgumentVariant_SolverAnswer_SingleMarks::result_of_calculation() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.result_of_calculation)
  return static_cast< ::SolverClient::ResultOfCalculation >(result_of_calculation_);
}
inline void Packet_ArgumentVariant_SolverAnswer_SingleMarks::set_result_of_calculation(::SolverClient::ResultOfCalculation value) {
  assert(::SolverClient::ResultOfCalculation_IsValid(value));
  set_has_result_of_calculation();
  result_of_calculation_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.result_of_calculation)
}

// repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.CoordsEstimate coordsEstimate = 2;
inline int Packet_ArgumentVariant_SolverAnswer_SingleMarks::coordsestimate_size() const {
  return coordsestimate_.size();
}
inline void Packet_ArgumentVariant_SolverAnswer_SingleMarks::clear_coordsestimate() {
  coordsestimate_.Clear();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate& Packet_ArgumentVariant_SolverAnswer_SingleMarks::coordsestimate(int index) const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.coordsEstimate)
  return coordsestimate_.Get(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* Packet_ArgumentVariant_SolverAnswer_SingleMarks::mutable_coordsestimate(int index) {
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.coordsEstimate)
  return coordsestimate_.Mutable(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate* Packet_ArgumentVariant_SolverAnswer_SingleMarks::add_coordsestimate() {
  // @@protoc_insertion_point(field_add:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.coordsEstimate)
  return coordsestimate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate >&
Packet_ArgumentVariant_SolverAnswer_SingleMarks::coordsestimate() const {
  // @@protoc_insertion_point(field_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.coordsEstimate)
  return coordsestimate_;
}
inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_CoordsEstimate >*
Packet_ArgumentVariant_SolverAnswer_SingleMarks::mutable_coordsestimate() {
  // @@protoc_insertion_point(field_mutable_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks.coordsEstimate)
  return &coordsestimate_;
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon

// required double lat = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::lat() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon.lat)
  return lat_;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon.lat)
}

// required double lon = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::lon() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon.lon)
  return lon_;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon.lon)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine

// repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.LatLon point = 1;
inline int Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::point_size() const {
  return point_.size();
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::clear_point() {
  point_.Clear();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon& Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::point(int index) const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.point)
  return point_.Get(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.point)
  return point_.Mutable(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon* Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::add_point() {
  // @@protoc_insertion_point(field_add:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.point)
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon >&
Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::point() const {
  // @@protoc_insertion_point(field_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.point)
  return point_;
}
inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine_LatLon >*
Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine.point)
  return &point_;
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_StateLines

// required .SolverClient.ResultOfCalculation result_of_calculation = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_StateLines::has_result_of_calculation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::set_has_result_of_calculation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::clear_has_result_of_calculation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::clear_result_of_calculation() {
  result_of_calculation_ = 1;
  clear_has_result_of_calculation();
}
inline ::SolverClient::ResultOfCalculation Packet_ArgumentVariant_SolverAnswer_StateLines::result_of_calculation() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.result_of_calculation)
  return static_cast< ::SolverClient::ResultOfCalculation >(result_of_calculation_);
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::set_result_of_calculation(::SolverClient::ResultOfCalculation value) {
  assert(::SolverClient::ResultOfCalculation_IsValid(value));
  set_has_result_of_calculation();
  result_of_calculation_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.result_of_calculation)
}

// required int64 datetime = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_StateLines::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 Packet_ArgumentVariant_SolverAnswer_StateLines::datetime() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.datetime)
  return datetime_;
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.datetime)
}

// repeated .SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.StateLine stateLine = 3;
inline int Packet_ArgumentVariant_SolverAnswer_StateLines::stateline_size() const {
  return stateline_.size();
}
inline void Packet_ArgumentVariant_SolverAnswer_StateLines::clear_stateline() {
  stateline_.Clear();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine& Packet_ArgumentVariant_SolverAnswer_StateLines::stateline(int index) const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.stateLine)
  return stateline_.Get(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* Packet_ArgumentVariant_SolverAnswer_StateLines::mutable_stateline(int index) {
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.stateLine)
  return stateline_.Mutable(index);
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine* Packet_ArgumentVariant_SolverAnswer_StateLines::add_stateline() {
  // @@protoc_insertion_point(field_add:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.stateLine)
  return stateline_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine >&
Packet_ArgumentVariant_SolverAnswer_StateLines::stateline() const {
  // @@protoc_insertion_point(field_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.stateLine)
  return stateline_;
}
inline ::google::protobuf::RepeatedPtrField< ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines_StateLine >*
Packet_ArgumentVariant_SolverAnswer_StateLines::mutable_stateline() {
  // @@protoc_insertion_point(field_mutable_list:SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines.stateLine)
  return &stateline_;
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer_ErrorMessage

// required .SolverClient.SolverError errorType = 1;
inline bool Packet_ArgumentVariant_SolverAnswer_ErrorMessage::has_errortype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_has_errortype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::clear_has_errortype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::clear_errortype() {
  errortype_ = 1;
  clear_has_errortype();
}
inline ::SolverClient::SolverError Packet_ArgumentVariant_SolverAnswer_ErrorMessage::errortype() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.errorType)
  return static_cast< ::SolverClient::SolverError >(errortype_);
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_errortype(::SolverClient::SolverError value) {
  assert(::SolverClient::SolverError_IsValid(value));
  set_has_errortype();
  errortype_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.errorType)
}

// required string message = 2;
inline bool Packet_ArgumentVariant_SolverAnswer_ErrorMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Packet_ArgumentVariant_SolverAnswer_ErrorMessage::message() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.message)
  return *message_;
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.message)
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.message)
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.message)
}
inline ::std::string* Packet_ArgumentVariant_SolverAnswer_ErrorMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.message)
  return message_;
}
inline ::std::string* Packet_ArgumentVariant_SolverAnswer_ErrorMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Packet_ArgumentVariant_SolverAnswer_ErrorMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage.message)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverAnswer

// required uint32 TargetID = 1;
inline bool Packet_ArgumentVariant_SolverAnswer::has_targetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_has_targetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_targetid() {
  targetid_ = 0u;
  clear_has_targetid();
}
inline ::google::protobuf::uint32 Packet_ArgumentVariant_SolverAnswer::targetid() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.TargetID)
  return targetid_;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_targetid(::google::protobuf::uint32 value) {
  set_has_targetid();
  targetid_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.ArgumentVariant.SolverAnswer.TargetID)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory auto_trajectory = 2;
inline bool Packet_ArgumentVariant_SolverAnswer::has_auto_trajectory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_has_auto_trajectory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_has_auto_trajectory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_auto_trajectory() {
  if (auto_trajectory_ != NULL) auto_trajectory_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory::Clear();
  clear_has_auto_trajectory();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory& Packet_ArgumentVariant_SolverAnswer::auto_trajectory() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.auto_trajectory)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return auto_trajectory_ != NULL ? *auto_trajectory_ : *default_instance().auto_trajectory_;
#else
  return auto_trajectory_ != NULL ? *auto_trajectory_ : *default_instance_->auto_trajectory_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* Packet_ArgumentVariant_SolverAnswer::mutable_auto_trajectory() {
  set_has_auto_trajectory();
  if (auto_trajectory_ == NULL) auto_trajectory_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.auto_trajectory)
  return auto_trajectory_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* Packet_ArgumentVariant_SolverAnswer::release_auto_trajectory() {
  clear_has_auto_trajectory();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* temp = auto_trajectory_;
  auto_trajectory_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_allocated_auto_trajectory(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* auto_trajectory) {
  delete auto_trajectory_;
  auto_trajectory_ = auto_trajectory;
  if (auto_trajectory) {
    set_has_auto_trajectory();
  } else {
    clear_has_auto_trajectory();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.auto_trajectory)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.Trajectory manual_trajectory = 3;
inline bool Packet_ArgumentVariant_SolverAnswer::has_manual_trajectory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_has_manual_trajectory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_has_manual_trajectory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_manual_trajectory() {
  if (manual_trajectory_ != NULL) manual_trajectory_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory::Clear();
  clear_has_manual_trajectory();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory& Packet_ArgumentVariant_SolverAnswer::manual_trajectory() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.manual_trajectory)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return manual_trajectory_ != NULL ? *manual_trajectory_ : *default_instance().manual_trajectory_;
#else
  return manual_trajectory_ != NULL ? *manual_trajectory_ : *default_instance_->manual_trajectory_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* Packet_ArgumentVariant_SolverAnswer::mutable_manual_trajectory() {
  set_has_manual_trajectory();
  if (manual_trajectory_ == NULL) manual_trajectory_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.manual_trajectory)
  return manual_trajectory_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* Packet_ArgumentVariant_SolverAnswer::release_manual_trajectory() {
  clear_has_manual_trajectory();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* temp = manual_trajectory_;
  manual_trajectory_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_allocated_manual_trajectory(::SolverClient::Packet_ArgumentVariant_SolverAnswer_Trajectory* manual_trajectory) {
  delete manual_trajectory_;
  manual_trajectory_ = manual_trajectory;
  if (manual_trajectory) {
    set_has_manual_trajectory();
  } else {
    clear_has_manual_trajectory();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.manual_trajectory)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.SingleMarks singleMarks = 4;
inline bool Packet_ArgumentVariant_SolverAnswer::has_singlemarks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_has_singlemarks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_has_singlemarks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_singlemarks() {
  if (singlemarks_ != NULL) singlemarks_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks::Clear();
  clear_has_singlemarks();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks& Packet_ArgumentVariant_SolverAnswer::singlemarks() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.singleMarks)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return singlemarks_ != NULL ? *singlemarks_ : *default_instance().singlemarks_;
#else
  return singlemarks_ != NULL ? *singlemarks_ : *default_instance_->singlemarks_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* Packet_ArgumentVariant_SolverAnswer::mutable_singlemarks() {
  set_has_singlemarks();
  if (singlemarks_ == NULL) singlemarks_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.singleMarks)
  return singlemarks_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* Packet_ArgumentVariant_SolverAnswer::release_singlemarks() {
  clear_has_singlemarks();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* temp = singlemarks_;
  singlemarks_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_allocated_singlemarks(::SolverClient::Packet_ArgumentVariant_SolverAnswer_SingleMarks* singlemarks) {
  delete singlemarks_;
  singlemarks_ = singlemarks;
  if (singlemarks) {
    set_has_singlemarks();
  } else {
    clear_has_singlemarks();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.singleMarks)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.StateLines stateLines = 5;
inline bool Packet_ArgumentVariant_SolverAnswer::has_statelines() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_has_statelines() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_has_statelines() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_statelines() {
  if (statelines_ != NULL) statelines_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines::Clear();
  clear_has_statelines();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines& Packet_ArgumentVariant_SolverAnswer::statelines() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.stateLines)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return statelines_ != NULL ? *statelines_ : *default_instance().statelines_;
#else
  return statelines_ != NULL ? *statelines_ : *default_instance_->statelines_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* Packet_ArgumentVariant_SolverAnswer::mutable_statelines() {
  set_has_statelines();
  if (statelines_ == NULL) statelines_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.stateLines)
  return statelines_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* Packet_ArgumentVariant_SolverAnswer::release_statelines() {
  clear_has_statelines();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* temp = statelines_;
  statelines_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_allocated_statelines(::SolverClient::Packet_ArgumentVariant_SolverAnswer_StateLines* statelines) {
  delete statelines_;
  statelines_ = statelines;
  if (statelines) {
    set_has_statelines();
  } else {
    clear_has_statelines();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.stateLines)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverAnswer.ErrorMessage errorMessage = 6;
inline bool Packet_ArgumentVariant_SolverAnswer::has_errormessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_has_errormessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ArgumentVariant_SolverAnswer::clear_errormessage() {
  if (errormessage_ != NULL) errormessage_->::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage::Clear();
  clear_has_errormessage();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage& Packet_ArgumentVariant_SolverAnswer::errormessage() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.SolverAnswer.errorMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return errormessage_ != NULL ? *errormessage_ : *default_instance().errormessage_;
#else
  return errormessage_ != NULL ? *errormessage_ : *default_instance_->errormessage_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* Packet_ArgumentVariant_SolverAnswer::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == NULL) errormessage_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.SolverAnswer.errorMessage)
  return errormessage_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* Packet_ArgumentVariant_SolverAnswer::release_errormessage() {
  clear_has_errormessage();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* temp = errormessage_;
  errormessage_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_SolverAnswer::set_allocated_errormessage(::SolverClient::Packet_ArgumentVariant_SolverAnswer_ErrorMessage* errormessage) {
  delete errormessage_;
  errormessage_ = errormessage;
  if (errormessage) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.SolverAnswer.errorMessage)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant

// optional .SolverClient.Packet.ArgumentVariant.BplaPosition bplaPoisition = 1;
inline bool Packet_ArgumentVariant::has_bplapoisition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant::set_has_bplapoisition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant::clear_has_bplapoisition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant::clear_bplapoisition() {
  if (bplapoisition_ != NULL) bplapoisition_->::SolverClient::Packet_ArgumentVariant_BplaPosition::Clear();
  clear_has_bplapoisition();
}
inline const ::SolverClient::Packet_ArgumentVariant_BplaPosition& Packet_ArgumentVariant::bplapoisition() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.bplaPoisition)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bplapoisition_ != NULL ? *bplapoisition_ : *default_instance().bplapoisition_;
#else
  return bplapoisition_ != NULL ? *bplapoisition_ : *default_instance_->bplapoisition_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_BplaPosition* Packet_ArgumentVariant::mutable_bplapoisition() {
  set_has_bplapoisition();
  if (bplapoisition_ == NULL) bplapoisition_ = new ::SolverClient::Packet_ArgumentVariant_BplaPosition;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.bplaPoisition)
  return bplapoisition_;
}
inline ::SolverClient::Packet_ArgumentVariant_BplaPosition* Packet_ArgumentVariant::release_bplapoisition() {
  clear_has_bplapoisition();
  ::SolverClient::Packet_ArgumentVariant_BplaPosition* temp = bplapoisition_;
  bplapoisition_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant::set_allocated_bplapoisition(::SolverClient::Packet_ArgumentVariant_BplaPosition* bplapoisition) {
  delete bplapoisition_;
  bplapoisition_ = bplapoisition;
  if (bplapoisition) {
    set_has_bplapoisition();
  } else {
    clear_has_bplapoisition();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.bplaPoisition)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverInput solverInput = 2;
inline bool Packet_ArgumentVariant::has_solverinput() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant::set_has_solverinput() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant::clear_has_solverinput() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant::clear_solverinput() {
  if (solverinput_ != NULL) solverinput_->::SolverClient::Packet_ArgumentVariant_SolverInput::Clear();
  clear_has_solverinput();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverInput& Packet_ArgumentVariant::solverinput() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.solverInput)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return solverinput_ != NULL ? *solverinput_ : *default_instance().solverinput_;
#else
  return solverinput_ != NULL ? *solverinput_ : *default_instance_->solverinput_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverInput* Packet_ArgumentVariant::mutable_solverinput() {
  set_has_solverinput();
  if (solverinput_ == NULL) solverinput_ = new ::SolverClient::Packet_ArgumentVariant_SolverInput;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.solverInput)
  return solverinput_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverInput* Packet_ArgumentVariant::release_solverinput() {
  clear_has_solverinput();
  ::SolverClient::Packet_ArgumentVariant_SolverInput* temp = solverinput_;
  solverinput_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant::set_allocated_solverinput(::SolverClient::Packet_ArgumentVariant_SolverInput* solverinput) {
  delete solverinput_;
  solverinput_ = solverinput;
  if (solverinput) {
    set_has_solverinput();
  } else {
    clear_has_solverinput();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.solverInput)
}

// optional .SolverClient.Packet.ArgumentVariant.SolverAnswer solverAnswer = 3;
inline bool Packet_ArgumentVariant::has_solveranswer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant::set_has_solveranswer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant::clear_has_solveranswer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant::clear_solveranswer() {
  if (solveranswer_ != NULL) solveranswer_->::SolverClient::Packet_ArgumentVariant_SolverAnswer::Clear();
  clear_has_solveranswer();
}
inline const ::SolverClient::Packet_ArgumentVariant_SolverAnswer& Packet_ArgumentVariant::solveranswer() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.ArgumentVariant.solverAnswer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return solveranswer_ != NULL ? *solveranswer_ : *default_instance().solveranswer_;
#else
  return solveranswer_ != NULL ? *solveranswer_ : *default_instance_->solveranswer_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer* Packet_ArgumentVariant::mutable_solveranswer() {
  set_has_solveranswer();
  if (solveranswer_ == NULL) solveranswer_ = new ::SolverClient::Packet_ArgumentVariant_SolverAnswer;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.ArgumentVariant.solverAnswer)
  return solveranswer_;
}
inline ::SolverClient::Packet_ArgumentVariant_SolverAnswer* Packet_ArgumentVariant::release_solveranswer() {
  clear_has_solveranswer();
  ::SolverClient::Packet_ArgumentVariant_SolverAnswer* temp = solveranswer_;
  solveranswer_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant::set_allocated_solveranswer(::SolverClient::Packet_ArgumentVariant_SolverAnswer* solveranswer) {
  delete solveranswer_;
  solveranswer_ = solveranswer;
  if (solveranswer) {
    set_has_solveranswer();
  } else {
    clear_has_solveranswer();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.ArgumentVariant.solverAnswer)
}

// -------------------------------------------------------------------

// Packet_Command

// required .SolverClient.Actions action = 1 [default = unknownAction];
inline bool Packet_Command::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Command::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Command::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Command::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::SolverClient::Actions Packet_Command::action() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.Command.action)
  return static_cast< ::SolverClient::Actions >(action_);
}
inline void Packet_Command::set_action(::SolverClient::Actions value) {
  assert(::SolverClient::Actions_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:SolverClient.Packet.Command.action)
}

// optional .SolverClient.Packet.ArgumentVariant arguments = 2;
inline bool Packet_Command::has_arguments() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Command::set_has_arguments() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Command::clear_has_arguments() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Command::clear_arguments() {
  if (arguments_ != NULL) arguments_->::SolverClient::Packet_ArgumentVariant::Clear();
  clear_has_arguments();
}
inline const ::SolverClient::Packet_ArgumentVariant& Packet_Command::arguments() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.Command.arguments)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return arguments_ != NULL ? *arguments_ : *default_instance().arguments_;
#else
  return arguments_ != NULL ? *arguments_ : *default_instance_->arguments_;
#endif
}
inline ::SolverClient::Packet_ArgumentVariant* Packet_Command::mutable_arguments() {
  set_has_arguments();
  if (arguments_ == NULL) arguments_ = new ::SolverClient::Packet_ArgumentVariant;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.Command.arguments)
  return arguments_;
}
inline ::SolverClient::Packet_ArgumentVariant* Packet_Command::release_arguments() {
  clear_has_arguments();
  ::SolverClient::Packet_ArgumentVariant* temp = arguments_;
  arguments_ = NULL;
  return temp;
}
inline void Packet_Command::set_allocated_arguments(::SolverClient::Packet_ArgumentVariant* arguments) {
  delete arguments_;
  arguments_ = arguments;
  if (arguments) {
    set_has_arguments();
  } else {
    clear_has_arguments();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.Command.arguments)
}

// -------------------------------------------------------------------

// Packet

// required .SolverClient.Packet.Command command = 1;
inline bool Packet::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_command() {
  if (command_ != NULL) command_->::SolverClient::Packet_Command::Clear();
  clear_has_command();
}
inline const ::SolverClient::Packet_Command& Packet::command() const {
  // @@protoc_insertion_point(field_get:SolverClient.Packet.command)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return command_ != NULL ? *command_ : *default_instance().command_;
#else
  return command_ != NULL ? *command_ : *default_instance_->command_;
#endif
}
inline ::SolverClient::Packet_Command* Packet::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::SolverClient::Packet_Command;
  // @@protoc_insertion_point(field_mutable:SolverClient.Packet.command)
  return command_;
}
inline ::SolverClient::Packet_Command* Packet::release_command() {
  clear_has_command();
  ::SolverClient::Packet_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Packet::set_allocated_command(::SolverClient::Packet_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:SolverClient.Packet.command)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SolverClient

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SolverPacket_2eproto__INCLUDED
