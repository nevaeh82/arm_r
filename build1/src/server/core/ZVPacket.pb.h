// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZVPacket.proto

#ifndef PROTOBUF_ZVPacket_2eproto__INCLUDED
#define PROTOBUF_ZVPacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace Zaviruha {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ZVPacket_2eproto();
void protobuf_AssignDesc_ZVPacket_2eproto();
void protobuf_ShutdownFile_ZVPacket_2eproto();

class Packet;
class Packet_ArgumentVariant;
class Packet_ArgumentVariant_Header;
class Packet_ArgumentVariant_AtlantDirection;
class Packet_ArgumentVariant_AtlantPosition;
class Packet_ArgumentVariant_BplaPoints;
class Packet_ArgumentVariant_BplaPoints_Point;
class Packet_ArgumentVariant_SolverData;
class Packet_Command;

enum Actions {
  unknownAction = 0,
  sendAtlantDirection = 1,
  sendAtlantPosition = 2,
  sendBplaPoints = 3,
  sendBplaPointsAuto = 4,
  sendSolverData = 5,
  sendSolverClear = 6
};
bool Actions_IsValid(int value);
const Actions Actions_MIN = unknownAction;
const Actions Actions_MAX = sendSolverClear;
const int Actions_ARRAYSIZE = Actions_MAX + 1;

// ===================================================================

class Packet_ArgumentVariant_Header : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_Header();
  virtual ~Packet_ArgumentVariant_Header();

  Packet_ArgumentVariant_Header(const Packet_ArgumentVariant_Header& from);

  inline Packet_ArgumentVariant_Header& operator=(const Packet_ArgumentVariant_Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_Header& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_Header* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_Header* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_Header* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_Header& from);
  void MergeFrom(const Packet_ArgumentVariant_Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required int32 sourceId = 2;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::int32 sourceid() const;
  inline void set_sourceid(::google::protobuf::int32 value);

  // required uint64 dateTime = 3;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 datetime() const;
  inline void set_datetime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant.Header)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 sourceid_;
  ::google::protobuf::uint64 datetime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_Header* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_AtlantDirection : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_AtlantDirection();
  virtual ~Packet_ArgumentVariant_AtlantDirection();

  Packet_ArgumentVariant_AtlantDirection(const Packet_ArgumentVariant_AtlantDirection& from);

  inline Packet_ArgumentVariant_AtlantDirection& operator=(const Packet_ArgumentVariant_AtlantDirection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_AtlantDirection& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_AtlantDirection* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_AtlantDirection* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_AtlantDirection* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_AtlantDirection& from);
  void MergeFrom(const Packet_ArgumentVariant_AtlantDirection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Zaviruha.Packet.ArgumentVariant.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::Zaviruha::Packet_ArgumentVariant_Header& header() const;
  inline ::Zaviruha::Packet_ArgumentVariant_Header* mutable_header();
  inline ::Zaviruha::Packet_ArgumentVariant_Header* release_header();
  inline void set_allocated_header(::Zaviruha::Packet_ArgumentVariant_Header* header);

  // required string postName = 2;
  inline bool has_postname() const;
  inline void clear_postname();
  static const int kPostNameFieldNumber = 2;
  inline const ::std::string& postname() const;
  inline void set_postname(const ::std::string& value);
  inline void set_postname(const char* value);
  inline void set_postname(const char* value, size_t size);
  inline ::std::string* mutable_postname();
  inline ::std::string* release_postname();
  inline void set_allocated_postname(::std::string* postname);

  // required double postLatitude = 3;
  inline bool has_postlatitude() const;
  inline void clear_postlatitude();
  static const int kPostLatitudeFieldNumber = 3;
  inline double postlatitude() const;
  inline void set_postlatitude(double value);

  // required double postLongitude = 4;
  inline bool has_postlongitude() const;
  inline void clear_postlongitude();
  static const int kPostLongitudeFieldNumber = 4;
  inline double postlongitude() const;
  inline void set_postlongitude(double value);

  // required double postHeight = 5;
  inline bool has_postheight() const;
  inline void clear_postheight();
  static const int kPostHeightFieldNumber = 5;
  inline double postheight() const;
  inline void set_postheight(double value);

  // required double frequency = 6;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 6;
  inline double frequency() const;
  inline void set_frequency(double value);

  // required double width = 7;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 7;
  inline double width() const;
  inline void set_width(double value);

  // required double direction = 8;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 8;
  inline double direction() const;
  inline void set_direction(double value);

  // required double angle = 9;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 9;
  inline double angle() const;
  inline void set_angle(double value);

  // required double level = 10;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 10;
  inline double level() const;
  inline void set_level(double value);

  // required double quality = 11;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 11;
  inline double quality() const;
  inline void set_quality(double value);

  // required int32 motionType = 12;
  inline bool has_motiontype() const;
  inline void clear_motiontype();
  static const int kMotionTypeFieldNumber = 12;
  inline ::google::protobuf::int32 motiontype() const;
  inline void set_motiontype(::google::protobuf::int32 value);

  // required double motionConfidence = 13;
  inline bool has_motionconfidence() const;
  inline void clear_motionconfidence();
  static const int kMotionConfidenceFieldNumber = 13;
  inline double motionconfidence() const;
  inline void set_motionconfidence(double value);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant.AtlantDirection)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_postname();
  inline void clear_has_postname();
  inline void set_has_postlatitude();
  inline void clear_has_postlatitude();
  inline void set_has_postlongitude();
  inline void clear_has_postlongitude();
  inline void set_has_postheight();
  inline void clear_has_postheight();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_motiontype();
  inline void clear_has_motiontype();
  inline void set_has_motionconfidence();
  inline void clear_has_motionconfidence();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Zaviruha::Packet_ArgumentVariant_Header* header_;
  ::std::string* postname_;
  double postlatitude_;
  double postlongitude_;
  double postheight_;
  double frequency_;
  double width_;
  double direction_;
  double angle_;
  double level_;
  double quality_;
  double motionconfidence_;
  ::google::protobuf::int32 motiontype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_AtlantDirection* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_AtlantPosition : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_AtlantPosition();
  virtual ~Packet_ArgumentVariant_AtlantPosition();

  Packet_ArgumentVariant_AtlantPosition(const Packet_ArgumentVariant_AtlantPosition& from);

  inline Packet_ArgumentVariant_AtlantPosition& operator=(const Packet_ArgumentVariant_AtlantPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_AtlantPosition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_AtlantPosition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_AtlantPosition* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_AtlantPosition* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_AtlantPosition& from);
  void MergeFrom(const Packet_ArgumentVariant_AtlantPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Zaviruha.Packet.ArgumentVariant.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::Zaviruha::Packet_ArgumentVariant_Header& header() const;
  inline ::Zaviruha::Packet_ArgumentVariant_Header* mutable_header();
  inline ::Zaviruha::Packet_ArgumentVariant_Header* release_header();
  inline void set_allocated_header(::Zaviruha::Packet_ArgumentVariant_Header* header);

  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // required double latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline double latitude() const;
  inline void set_latitude(double value);

  // required double quality = 4;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 4;
  inline double quality() const;
  inline void set_quality(double value);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant.AtlantPosition)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_quality();
  inline void clear_has_quality();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Zaviruha::Packet_ArgumentVariant_Header* header_;
  double longitude_;
  double latitude_;
  double quality_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_AtlantPosition* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_BplaPoints_Point : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_BplaPoints_Point();
  virtual ~Packet_ArgumentVariant_BplaPoints_Point();

  Packet_ArgumentVariant_BplaPoints_Point(const Packet_ArgumentVariant_BplaPoints_Point& from);

  inline Packet_ArgumentVariant_BplaPoints_Point& operator=(const Packet_ArgumentVariant_BplaPoints_Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_BplaPoints_Point& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_BplaPoints_Point* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_BplaPoints_Point* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_BplaPoints_Point* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_BplaPoints_Point& from);
  void MergeFrom(const Packet_ArgumentVariant_BplaPoints_Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant.BplaPoints.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_BplaPoints_Point* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_BplaPoints : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_BplaPoints();
  virtual ~Packet_ArgumentVariant_BplaPoints();

  Packet_ArgumentVariant_BplaPoints(const Packet_ArgumentVariant_BplaPoints& from);

  inline Packet_ArgumentVariant_BplaPoints& operator=(const Packet_ArgumentVariant_BplaPoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_BplaPoints& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_BplaPoints* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_BplaPoints* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_BplaPoints* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_BplaPoints& from);
  void MergeFrom(const Packet_ArgumentVariant_BplaPoints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_BplaPoints_Point Point;

  // accessors -------------------------------------------------------

  // required uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required int32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // required .Zaviruha.Packet.ArgumentVariant.BplaPoints.Point pointStdDev = 3;
  inline bool has_pointstddev() const;
  inline void clear_pointstddev();
  static const int kPointStdDevFieldNumber = 3;
  inline const ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point& pointstddev() const;
  inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* mutable_pointstddev();
  inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* release_pointstddev();
  inline void set_allocated_pointstddev(::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* pointstddev);

  // repeated .Zaviruha.Packet.ArgumentVariant.BplaPoints.Point track = 4;
  inline int track_size() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 4;
  inline const ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point& track(int index) const;
  inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* mutable_track(int index);
  inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* add_track();
  inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point >&
      track() const;
  inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point >*
      mutable_track();

  // required double speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline double speed() const;
  inline void set_speed(double value);

  // required double altitude = 6;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 6;
  inline double altitude() const;
  inline void set_altitude(double value);

  // required double course = 7;
  inline bool has_course() const;
  inline void clear_course();
  static const int kCourseFieldNumber = 7;
  inline double course() const;
  inline void set_course(double value);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant.BplaPoints)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_pointstddev();
  inline void clear_has_pointstddev();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_course();
  inline void clear_has_course();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* pointstddev_;
  ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point > track_;
  double speed_;
  double altitude_;
  double course_;
  ::google::protobuf::int32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_BplaPoints* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant_SolverData : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant_SolverData();
  virtual ~Packet_ArgumentVariant_SolverData();

  Packet_ArgumentVariant_SolverData(const Packet_ArgumentVariant_SolverData& from);

  inline Packet_ArgumentVariant_SolverData& operator=(const Packet_ArgumentVariant_SolverData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant_SolverData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant_SolverData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant_SolverData* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant_SolverData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant_SolverData& from);
  void MergeFrom(const Packet_ArgumentVariant_SolverData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required double altitude = 2;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 2;
  inline double altitude() const;
  inline void set_altitude(double value);

  // required int32 trackLength = 3;
  inline bool has_tracklength() const;
  inline void clear_tracklength();
  static const int kTrackLengthFieldNumber = 3;
  inline ::google::protobuf::int32 tracklength() const;
  inline void set_tracklength(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant.SolverData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_tracklength();
  inline void clear_has_tracklength();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double altitude_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 tracklength_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant_SolverData* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ArgumentVariant : public ::google::protobuf::MessageLite {
 public:
  Packet_ArgumentVariant();
  virtual ~Packet_ArgumentVariant();

  Packet_ArgumentVariant(const Packet_ArgumentVariant& from);

  inline Packet_ArgumentVariant& operator=(const Packet_ArgumentVariant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_ArgumentVariant& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_ArgumentVariant* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_ArgumentVariant* other);

  // implements Message ----------------------------------------------

  Packet_ArgumentVariant* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_ArgumentVariant& from);
  void MergeFrom(const Packet_ArgumentVariant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant_Header Header;
  typedef Packet_ArgumentVariant_AtlantDirection AtlantDirection;
  typedef Packet_ArgumentVariant_AtlantPosition AtlantPosition;
  typedef Packet_ArgumentVariant_BplaPoints BplaPoints;
  typedef Packet_ArgumentVariant_SolverData SolverData;

  // accessors -------------------------------------------------------

  // repeated .Zaviruha.Packet.ArgumentVariant.AtlantDirection atlantDirection = 1;
  inline int atlantdirection_size() const;
  inline void clear_atlantdirection();
  static const int kAtlantDirectionFieldNumber = 1;
  inline const ::Zaviruha::Packet_ArgumentVariant_AtlantDirection& atlantdirection(int index) const;
  inline ::Zaviruha::Packet_ArgumentVariant_AtlantDirection* mutable_atlantdirection(int index);
  inline ::Zaviruha::Packet_ArgumentVariant_AtlantDirection* add_atlantdirection();
  inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantDirection >&
      atlantdirection() const;
  inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantDirection >*
      mutable_atlantdirection();

  // repeated .Zaviruha.Packet.ArgumentVariant.AtlantPosition atlantPosition = 2;
  inline int atlantposition_size() const;
  inline void clear_atlantposition();
  static const int kAtlantPositionFieldNumber = 2;
  inline const ::Zaviruha::Packet_ArgumentVariant_AtlantPosition& atlantposition(int index) const;
  inline ::Zaviruha::Packet_ArgumentVariant_AtlantPosition* mutable_atlantposition(int index);
  inline ::Zaviruha::Packet_ArgumentVariant_AtlantPosition* add_atlantposition();
  inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantPosition >&
      atlantposition() const;
  inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantPosition >*
      mutable_atlantposition();

  // repeated .Zaviruha.Packet.ArgumentVariant.BplaPoints bplaPoints = 3;
  inline int bplapoints_size() const;
  inline void clear_bplapoints();
  static const int kBplaPointsFieldNumber = 3;
  inline const ::Zaviruha::Packet_ArgumentVariant_BplaPoints& bplapoints(int index) const;
  inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints* mutable_bplapoints(int index);
  inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints* add_bplapoints();
  inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints >&
      bplapoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints >*
      mutable_bplapoints();

  // repeated .Zaviruha.Packet.ArgumentVariant.SolverData solverData = 4;
  inline int solverdata_size() const;
  inline void clear_solverdata();
  static const int kSolverDataFieldNumber = 4;
  inline const ::Zaviruha::Packet_ArgumentVariant_SolverData& solverdata(int index) const;
  inline ::Zaviruha::Packet_ArgumentVariant_SolverData* mutable_solverdata(int index);
  inline ::Zaviruha::Packet_ArgumentVariant_SolverData* add_solverdata();
  inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_SolverData >&
      solverdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_SolverData >*
      mutable_solverdata();

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.ArgumentVariant)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantDirection > atlantdirection_;
  ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantPosition > atlantposition_;
  ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints > bplapoints_;
  ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_SolverData > solverdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_ArgumentVariant* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Command : public ::google::protobuf::MessageLite {
 public:
  Packet_Command();
  virtual ~Packet_Command();

  Packet_Command(const Packet_Command& from);

  inline Packet_Command& operator=(const Packet_Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet_Command& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet_Command* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet_Command* other);

  // implements Message ----------------------------------------------

  Packet_Command* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet_Command& from);
  void MergeFrom(const Packet_Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Zaviruha.Actions action = 1 [default = unknownAction];
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::Zaviruha::Actions action() const;
  inline void set_action(::Zaviruha::Actions value);

  // optional .Zaviruha.Packet.ArgumentVariant arguments = 2;
  inline bool has_arguments() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 2;
  inline const ::Zaviruha::Packet_ArgumentVariant& arguments() const;
  inline ::Zaviruha::Packet_ArgumentVariant* mutable_arguments();
  inline ::Zaviruha::Packet_ArgumentVariant* release_arguments();
  inline void set_allocated_arguments(::Zaviruha::Packet_ArgumentVariant* arguments);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet.Command)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_arguments();
  inline void clear_has_arguments();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Zaviruha::Packet_ArgumentVariant* arguments_;
  int action_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet_Command* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::MessageLite {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Packet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Packet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  Packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Packet_ArgumentVariant ArgumentVariant;
  typedef Packet_Command Command;

  // accessors -------------------------------------------------------

  // required .Zaviruha.Packet.Command command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::Zaviruha::Packet_Command& command() const;
  inline ::Zaviruha::Packet_Command* mutable_command();
  inline ::Zaviruha::Packet_Command* release_command();
  inline void set_allocated_command(::Zaviruha::Packet_Command* command);

  // @@protoc_insertion_point(class_scope:Zaviruha.Packet)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Zaviruha::Packet_Command* command_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ZVPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ZVPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_ZVPacket_2eproto();
  friend void protobuf_ShutdownFile_ZVPacket_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// ===================================================================


// ===================================================================

// Packet_ArgumentVariant_Header

// required int32 requestId = 1;
inline bool Packet_ArgumentVariant_Header::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_Header::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_Header::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_Header::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 Packet_ArgumentVariant_Header::requestid() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.Header.requestId)
  return requestid_;
}
inline void Packet_ArgumentVariant_Header::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.Header.requestId)
}

// required int32 sourceId = 2;
inline bool Packet_ArgumentVariant_Header::has_sourceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_Header::set_has_sourceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_Header::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_Header::clear_sourceid() {
  sourceid_ = 0;
  clear_has_sourceid();
}
inline ::google::protobuf::int32 Packet_ArgumentVariant_Header::sourceid() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.Header.sourceId)
  return sourceid_;
}
inline void Packet_ArgumentVariant_Header::set_sourceid(::google::protobuf::int32 value) {
  set_has_sourceid();
  sourceid_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.Header.sourceId)
}

// required uint64 dateTime = 3;
inline bool Packet_ArgumentVariant_Header::has_datetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_Header::set_has_datetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_Header::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_Header::clear_datetime() {
  datetime_ = GOOGLE_ULONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::uint64 Packet_ArgumentVariant_Header::datetime() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.Header.dateTime)
  return datetime_;
}
inline void Packet_ArgumentVariant_Header::set_datetime(::google::protobuf::uint64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.Header.dateTime)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_AtlantDirection

// required .Zaviruha.Packet.ArgumentVariant.Header header = 1;
inline bool Packet_ArgumentVariant_AtlantDirection::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_header() {
  if (header_ != NULL) header_->::Zaviruha::Packet_ArgumentVariant_Header::Clear();
  clear_has_header();
}
inline const ::Zaviruha::Packet_ArgumentVariant_Header& Packet_ArgumentVariant_AtlantDirection::header() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::Zaviruha::Packet_ArgumentVariant_Header* Packet_ArgumentVariant_AtlantDirection::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Zaviruha::Packet_ArgumentVariant_Header;
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.AtlantDirection.header)
  return header_;
}
inline ::Zaviruha::Packet_ArgumentVariant_Header* Packet_ArgumentVariant_AtlantDirection::release_header() {
  clear_has_header();
  ::Zaviruha::Packet_ArgumentVariant_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_allocated_header(::Zaviruha::Packet_ArgumentVariant_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:Zaviruha.Packet.ArgumentVariant.AtlantDirection.header)
}

// required string postName = 2;
inline bool Packet_ArgumentVariant_AtlantDirection::has_postname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_postname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_postname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_postname() {
  if (postname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    postname_->clear();
  }
  clear_has_postname();
}
inline const ::std::string& Packet_ArgumentVariant_AtlantDirection::postname() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postName)
  return *postname_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_postname(const ::std::string& value) {
  set_has_postname();
  if (postname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    postname_ = new ::std::string;
  }
  postname_->assign(value);
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postName)
}
inline void Packet_ArgumentVariant_AtlantDirection::set_postname(const char* value) {
  set_has_postname();
  if (postname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    postname_ = new ::std::string;
  }
  postname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postName)
}
inline void Packet_ArgumentVariant_AtlantDirection::set_postname(const char* value, size_t size) {
  set_has_postname();
  if (postname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    postname_ = new ::std::string;
  }
  postname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postName)
}
inline ::std::string* Packet_ArgumentVariant_AtlantDirection::mutable_postname() {
  set_has_postname();
  if (postname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    postname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postName)
  return postname_;
}
inline ::std::string* Packet_ArgumentVariant_AtlantDirection::release_postname() {
  clear_has_postname();
  if (postname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = postname_;
    postname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Packet_ArgumentVariant_AtlantDirection::set_allocated_postname(::std::string* postname) {
  if (postname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete postname_;
  }
  if (postname) {
    set_has_postname();
    postname_ = postname;
  } else {
    clear_has_postname();
    postname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postName)
}

// required double postLatitude = 3;
inline bool Packet_ArgumentVariant_AtlantDirection::has_postlatitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_postlatitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_postlatitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_postlatitude() {
  postlatitude_ = 0;
  clear_has_postlatitude();
}
inline double Packet_ArgumentVariant_AtlantDirection::postlatitude() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postLatitude)
  return postlatitude_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_postlatitude(double value) {
  set_has_postlatitude();
  postlatitude_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postLatitude)
}

// required double postLongitude = 4;
inline bool Packet_ArgumentVariant_AtlantDirection::has_postlongitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_postlongitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_postlongitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_postlongitude() {
  postlongitude_ = 0;
  clear_has_postlongitude();
}
inline double Packet_ArgumentVariant_AtlantDirection::postlongitude() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postLongitude)
  return postlongitude_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_postlongitude(double value) {
  set_has_postlongitude();
  postlongitude_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postLongitude)
}

// required double postHeight = 5;
inline bool Packet_ArgumentVariant_AtlantDirection::has_postheight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_postheight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_postheight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_postheight() {
  postheight_ = 0;
  clear_has_postheight();
}
inline double Packet_ArgumentVariant_AtlantDirection::postheight() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postHeight)
  return postheight_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_postheight(double value) {
  set_has_postheight();
  postheight_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.postHeight)
}

// required double frequency = 6;
inline bool Packet_ArgumentVariant_AtlantDirection::has_frequency() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_frequency() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double Packet_ArgumentVariant_AtlantDirection::frequency() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.frequency)
  return frequency_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.frequency)
}

// required double width = 7;
inline bool Packet_ArgumentVariant_AtlantDirection::has_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double Packet_ArgumentVariant_AtlantDirection::width() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.width)
  return width_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.width)
}

// required double direction = 8;
inline bool Packet_ArgumentVariant_AtlantDirection::has_direction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_direction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_direction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline double Packet_ArgumentVariant_AtlantDirection::direction() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.direction)
  return direction_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_direction(double value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.direction)
}

// required double angle = 9;
inline bool Packet_ArgumentVariant_AtlantDirection::has_angle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_angle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_angle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double Packet_ArgumentVariant_AtlantDirection::angle() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.angle)
  return angle_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_angle(double value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.angle)
}

// required double level = 10;
inline bool Packet_ArgumentVariant_AtlantDirection::has_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline double Packet_ArgumentVariant_AtlantDirection::level() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.level)
  return level_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_level(double value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.level)
}

// required double quality = 11;
inline bool Packet_ArgumentVariant_AtlantDirection::has_quality() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_quality() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_quality() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double Packet_ArgumentVariant_AtlantDirection::quality() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.quality)
  return quality_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_quality(double value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.quality)
}

// required int32 motionType = 12;
inline bool Packet_ArgumentVariant_AtlantDirection::has_motiontype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_motiontype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_motiontype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_motiontype() {
  motiontype_ = 0;
  clear_has_motiontype();
}
inline ::google::protobuf::int32 Packet_ArgumentVariant_AtlantDirection::motiontype() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.motionType)
  return motiontype_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_motiontype(::google::protobuf::int32 value) {
  set_has_motiontype();
  motiontype_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.motionType)
}

// required double motionConfidence = 13;
inline bool Packet_ArgumentVariant_AtlantDirection::has_motionconfidence() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_has_motionconfidence() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_has_motionconfidence() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Packet_ArgumentVariant_AtlantDirection::clear_motionconfidence() {
  motionconfidence_ = 0;
  clear_has_motionconfidence();
}
inline double Packet_ArgumentVariant_AtlantDirection::motionconfidence() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantDirection.motionConfidence)
  return motionconfidence_;
}
inline void Packet_ArgumentVariant_AtlantDirection::set_motionconfidence(double value) {
  set_has_motionconfidence();
  motionconfidence_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantDirection.motionConfidence)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_AtlantPosition

// required .Zaviruha.Packet.ArgumentVariant.Header header = 1;
inline bool Packet_ArgumentVariant_AtlantPosition::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_header() {
  if (header_ != NULL) header_->::Zaviruha::Packet_ArgumentVariant_Header::Clear();
  clear_has_header();
}
inline const ::Zaviruha::Packet_ArgumentVariant_Header& Packet_ArgumentVariant_AtlantPosition::header() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantPosition.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::Zaviruha::Packet_ArgumentVariant_Header* Packet_ArgumentVariant_AtlantPosition::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Zaviruha::Packet_ArgumentVariant_Header;
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.AtlantPosition.header)
  return header_;
}
inline ::Zaviruha::Packet_ArgumentVariant_Header* Packet_ArgumentVariant_AtlantPosition::release_header() {
  clear_has_header();
  ::Zaviruha::Packet_ArgumentVariant_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_allocated_header(::Zaviruha::Packet_ArgumentVariant_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:Zaviruha.Packet.ArgumentVariant.AtlantPosition.header)
}

// required double longitude = 2;
inline bool Packet_ArgumentVariant_AtlantPosition::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Packet_ArgumentVariant_AtlantPosition::longitude() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantPosition.longitude)
  return longitude_;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantPosition.longitude)
}

// required double latitude = 3;
inline bool Packet_ArgumentVariant_AtlantPosition::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Packet_ArgumentVariant_AtlantPosition::latitude() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantPosition.latitude)
  return latitude_;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantPosition.latitude)
}

// required double quality = 4;
inline bool Packet_ArgumentVariant_AtlantPosition::has_quality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_has_quality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_has_quality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ArgumentVariant_AtlantPosition::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double Packet_ArgumentVariant_AtlantPosition::quality() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.AtlantPosition.quality)
  return quality_;
}
inline void Packet_ArgumentVariant_AtlantPosition::set_quality(double value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.AtlantPosition.quality)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_BplaPoints_Point

// required float x = 1;
inline bool Packet_ArgumentVariant_BplaPoints_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Packet_ArgumentVariant_BplaPoints_Point::x() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.Point.x)
  return x_;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.Point.x)
}

// required float y = 2;
inline bool Packet_ArgumentVariant_BplaPoints_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Packet_ArgumentVariant_BplaPoints_Point::y() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.Point.y)
  return y_;
}
inline void Packet_ArgumentVariant_BplaPoints_Point::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.Point.y)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_BplaPoints

// required uint64 time = 1;
inline bool Packet_ArgumentVariant_BplaPoints::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Packet_ArgumentVariant_BplaPoints::time() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.time)
  return time_;
}
inline void Packet_ArgumentVariant_BplaPoints::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.time)
}

// required int32 state = 2;
inline bool Packet_ArgumentVariant_BplaPoints::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 Packet_ArgumentVariant_BplaPoints::state() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.state)
  return state_;
}
inline void Packet_ArgumentVariant_BplaPoints::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.state)
}

// required .Zaviruha.Packet.ArgumentVariant.BplaPoints.Point pointStdDev = 3;
inline bool Packet_ArgumentVariant_BplaPoints::has_pointstddev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints::set_has_pointstddev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_has_pointstddev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_pointstddev() {
  if (pointstddev_ != NULL) pointstddev_->::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point::Clear();
  clear_has_pointstddev();
}
inline const ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point& Packet_ArgumentVariant_BplaPoints::pointstddev() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.pointStdDev)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pointstddev_ != NULL ? *pointstddev_ : *default_instance().pointstddev_;
#else
  return pointstddev_ != NULL ? *pointstddev_ : *default_instance_->pointstddev_;
#endif
}
inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* Packet_ArgumentVariant_BplaPoints::mutable_pointstddev() {
  set_has_pointstddev();
  if (pointstddev_ == NULL) pointstddev_ = new ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point;
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.BplaPoints.pointStdDev)
  return pointstddev_;
}
inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* Packet_ArgumentVariant_BplaPoints::release_pointstddev() {
  clear_has_pointstddev();
  ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* temp = pointstddev_;
  pointstddev_ = NULL;
  return temp;
}
inline void Packet_ArgumentVariant_BplaPoints::set_allocated_pointstddev(::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* pointstddev) {
  delete pointstddev_;
  pointstddev_ = pointstddev;
  if (pointstddev) {
    set_has_pointstddev();
  } else {
    clear_has_pointstddev();
  }
  // @@protoc_insertion_point(field_set_allocated:Zaviruha.Packet.ArgumentVariant.BplaPoints.pointStdDev)
}

// repeated .Zaviruha.Packet.ArgumentVariant.BplaPoints.Point track = 4;
inline int Packet_ArgumentVariant_BplaPoints::track_size() const {
  return track_.size();
}
inline void Packet_ArgumentVariant_BplaPoints::clear_track() {
  track_.Clear();
}
inline const ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point& Packet_ArgumentVariant_BplaPoints::track(int index) const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.track)
  return track_.Get(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* Packet_ArgumentVariant_BplaPoints::mutable_track(int index) {
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.BplaPoints.track)
  return track_.Mutable(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point* Packet_ArgumentVariant_BplaPoints::add_track() {
  // @@protoc_insertion_point(field_add:Zaviruha.Packet.ArgumentVariant.BplaPoints.track)
  return track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point >&
Packet_ArgumentVariant_BplaPoints::track() const {
  // @@protoc_insertion_point(field_list:Zaviruha.Packet.ArgumentVariant.BplaPoints.track)
  return track_;
}
inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints_Point >*
Packet_ArgumentVariant_BplaPoints::mutable_track() {
  // @@protoc_insertion_point(field_mutable_list:Zaviruha.Packet.ArgumentVariant.BplaPoints.track)
  return &track_;
}

// required double speed = 5;
inline bool Packet_ArgumentVariant_BplaPoints::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Packet_ArgumentVariant_BplaPoints::speed() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.speed)
  return speed_;
}
inline void Packet_ArgumentVariant_BplaPoints::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.speed)
}

// required double altitude = 6;
inline bool Packet_ArgumentVariant_BplaPoints::has_altitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints::set_has_altitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double Packet_ArgumentVariant_BplaPoints::altitude() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.altitude)
  return altitude_;
}
inline void Packet_ArgumentVariant_BplaPoints::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.altitude)
}

// required double course = 7;
inline bool Packet_ArgumentVariant_BplaPoints::has_course() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ArgumentVariant_BplaPoints::set_has_course() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_has_course() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ArgumentVariant_BplaPoints::clear_course() {
  course_ = 0;
  clear_has_course();
}
inline double Packet_ArgumentVariant_BplaPoints::course() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.BplaPoints.course)
  return course_;
}
inline void Packet_ArgumentVariant_BplaPoints::set_course(double value) {
  set_has_course();
  course_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.BplaPoints.course)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant_SolverData

// required int32 id = 1;
inline bool Packet_ArgumentVariant_SolverData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ArgumentVariant_SolverData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ArgumentVariant_SolverData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ArgumentVariant_SolverData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Packet_ArgumentVariant_SolverData::id() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.SolverData.id)
  return id_;
}
inline void Packet_ArgumentVariant_SolverData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.SolverData.id)
}

// required double altitude = 2;
inline bool Packet_ArgumentVariant_SolverData::has_altitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ArgumentVariant_SolverData::set_has_altitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ArgumentVariant_SolverData::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ArgumentVariant_SolverData::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double Packet_ArgumentVariant_SolverData::altitude() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.SolverData.altitude)
  return altitude_;
}
inline void Packet_ArgumentVariant_SolverData::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.SolverData.altitude)
}

// required int32 trackLength = 3;
inline bool Packet_ArgumentVariant_SolverData::has_tracklength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ArgumentVariant_SolverData::set_has_tracklength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ArgumentVariant_SolverData::clear_has_tracklength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ArgumentVariant_SolverData::clear_tracklength() {
  tracklength_ = 0;
  clear_has_tracklength();
}
inline ::google::protobuf::int32 Packet_ArgumentVariant_SolverData::tracklength() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.SolverData.trackLength)
  return tracklength_;
}
inline void Packet_ArgumentVariant_SolverData::set_tracklength(::google::protobuf::int32 value) {
  set_has_tracklength();
  tracklength_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.ArgumentVariant.SolverData.trackLength)
}

// -------------------------------------------------------------------

// Packet_ArgumentVariant

// repeated .Zaviruha.Packet.ArgumentVariant.AtlantDirection atlantDirection = 1;
inline int Packet_ArgumentVariant::atlantdirection_size() const {
  return atlantdirection_.size();
}
inline void Packet_ArgumentVariant::clear_atlantdirection() {
  atlantdirection_.Clear();
}
inline const ::Zaviruha::Packet_ArgumentVariant_AtlantDirection& Packet_ArgumentVariant::atlantdirection(int index) const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.atlantDirection)
  return atlantdirection_.Get(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_AtlantDirection* Packet_ArgumentVariant::mutable_atlantdirection(int index) {
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.atlantDirection)
  return atlantdirection_.Mutable(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_AtlantDirection* Packet_ArgumentVariant::add_atlantdirection() {
  // @@protoc_insertion_point(field_add:Zaviruha.Packet.ArgumentVariant.atlantDirection)
  return atlantdirection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantDirection >&
Packet_ArgumentVariant::atlantdirection() const {
  // @@protoc_insertion_point(field_list:Zaviruha.Packet.ArgumentVariant.atlantDirection)
  return atlantdirection_;
}
inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantDirection >*
Packet_ArgumentVariant::mutable_atlantdirection() {
  // @@protoc_insertion_point(field_mutable_list:Zaviruha.Packet.ArgumentVariant.atlantDirection)
  return &atlantdirection_;
}

// repeated .Zaviruha.Packet.ArgumentVariant.AtlantPosition atlantPosition = 2;
inline int Packet_ArgumentVariant::atlantposition_size() const {
  return atlantposition_.size();
}
inline void Packet_ArgumentVariant::clear_atlantposition() {
  atlantposition_.Clear();
}
inline const ::Zaviruha::Packet_ArgumentVariant_AtlantPosition& Packet_ArgumentVariant::atlantposition(int index) const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.atlantPosition)
  return atlantposition_.Get(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_AtlantPosition* Packet_ArgumentVariant::mutable_atlantposition(int index) {
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.atlantPosition)
  return atlantposition_.Mutable(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_AtlantPosition* Packet_ArgumentVariant::add_atlantposition() {
  // @@protoc_insertion_point(field_add:Zaviruha.Packet.ArgumentVariant.atlantPosition)
  return atlantposition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantPosition >&
Packet_ArgumentVariant::atlantposition() const {
  // @@protoc_insertion_point(field_list:Zaviruha.Packet.ArgumentVariant.atlantPosition)
  return atlantposition_;
}
inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_AtlantPosition >*
Packet_ArgumentVariant::mutable_atlantposition() {
  // @@protoc_insertion_point(field_mutable_list:Zaviruha.Packet.ArgumentVariant.atlantPosition)
  return &atlantposition_;
}

// repeated .Zaviruha.Packet.ArgumentVariant.BplaPoints bplaPoints = 3;
inline int Packet_ArgumentVariant::bplapoints_size() const {
  return bplapoints_.size();
}
inline void Packet_ArgumentVariant::clear_bplapoints() {
  bplapoints_.Clear();
}
inline const ::Zaviruha::Packet_ArgumentVariant_BplaPoints& Packet_ArgumentVariant::bplapoints(int index) const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.bplaPoints)
  return bplapoints_.Get(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints* Packet_ArgumentVariant::mutable_bplapoints(int index) {
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.bplaPoints)
  return bplapoints_.Mutable(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_BplaPoints* Packet_ArgumentVariant::add_bplapoints() {
  // @@protoc_insertion_point(field_add:Zaviruha.Packet.ArgumentVariant.bplaPoints)
  return bplapoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints >&
Packet_ArgumentVariant::bplapoints() const {
  // @@protoc_insertion_point(field_list:Zaviruha.Packet.ArgumentVariant.bplaPoints)
  return bplapoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_BplaPoints >*
Packet_ArgumentVariant::mutable_bplapoints() {
  // @@protoc_insertion_point(field_mutable_list:Zaviruha.Packet.ArgumentVariant.bplaPoints)
  return &bplapoints_;
}

// repeated .Zaviruha.Packet.ArgumentVariant.SolverData solverData = 4;
inline int Packet_ArgumentVariant::solverdata_size() const {
  return solverdata_.size();
}
inline void Packet_ArgumentVariant::clear_solverdata() {
  solverdata_.Clear();
}
inline const ::Zaviruha::Packet_ArgumentVariant_SolverData& Packet_ArgumentVariant::solverdata(int index) const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.ArgumentVariant.solverData)
  return solverdata_.Get(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_SolverData* Packet_ArgumentVariant::mutable_solverdata(int index) {
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.ArgumentVariant.solverData)
  return solverdata_.Mutable(index);
}
inline ::Zaviruha::Packet_ArgumentVariant_SolverData* Packet_ArgumentVariant::add_solverdata() {
  // @@protoc_insertion_point(field_add:Zaviruha.Packet.ArgumentVariant.solverData)
  return solverdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_SolverData >&
Packet_ArgumentVariant::solverdata() const {
  // @@protoc_insertion_point(field_list:Zaviruha.Packet.ArgumentVariant.solverData)
  return solverdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::Zaviruha::Packet_ArgumentVariant_SolverData >*
Packet_ArgumentVariant::mutable_solverdata() {
  // @@protoc_insertion_point(field_mutable_list:Zaviruha.Packet.ArgumentVariant.solverData)
  return &solverdata_;
}

// -------------------------------------------------------------------

// Packet_Command

// required .Zaviruha.Actions action = 1 [default = unknownAction];
inline bool Packet_Command::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Command::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Command::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Command::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::Zaviruha::Actions Packet_Command::action() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.Command.action)
  return static_cast< ::Zaviruha::Actions >(action_);
}
inline void Packet_Command::set_action(::Zaviruha::Actions value) {
  assert(::Zaviruha::Actions_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Zaviruha.Packet.Command.action)
}

// optional .Zaviruha.Packet.ArgumentVariant arguments = 2;
inline bool Packet_Command::has_arguments() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Command::set_has_arguments() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Command::clear_has_arguments() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Command::clear_arguments() {
  if (arguments_ != NULL) arguments_->::Zaviruha::Packet_ArgumentVariant::Clear();
  clear_has_arguments();
}
inline const ::Zaviruha::Packet_ArgumentVariant& Packet_Command::arguments() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.Command.arguments)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return arguments_ != NULL ? *arguments_ : *default_instance().arguments_;
#else
  return arguments_ != NULL ? *arguments_ : *default_instance_->arguments_;
#endif
}
inline ::Zaviruha::Packet_ArgumentVariant* Packet_Command::mutable_arguments() {
  set_has_arguments();
  if (arguments_ == NULL) arguments_ = new ::Zaviruha::Packet_ArgumentVariant;
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.Command.arguments)
  return arguments_;
}
inline ::Zaviruha::Packet_ArgumentVariant* Packet_Command::release_arguments() {
  clear_has_arguments();
  ::Zaviruha::Packet_ArgumentVariant* temp = arguments_;
  arguments_ = NULL;
  return temp;
}
inline void Packet_Command::set_allocated_arguments(::Zaviruha::Packet_ArgumentVariant* arguments) {
  delete arguments_;
  arguments_ = arguments;
  if (arguments) {
    set_has_arguments();
  } else {
    clear_has_arguments();
  }
  // @@protoc_insertion_point(field_set_allocated:Zaviruha.Packet.Command.arguments)
}

// -------------------------------------------------------------------

// Packet

// required .Zaviruha.Packet.Command command = 1;
inline bool Packet::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_command() {
  if (command_ != NULL) command_->::Zaviruha::Packet_Command::Clear();
  clear_has_command();
}
inline const ::Zaviruha::Packet_Command& Packet::command() const {
  // @@protoc_insertion_point(field_get:Zaviruha.Packet.command)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return command_ != NULL ? *command_ : *default_instance().command_;
#else
  return command_ != NULL ? *command_ : *default_instance_->command_;
#endif
}
inline ::Zaviruha::Packet_Command* Packet::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::Zaviruha::Packet_Command;
  // @@protoc_insertion_point(field_mutable:Zaviruha.Packet.command)
  return command_;
}
inline ::Zaviruha::Packet_Command* Packet::release_command() {
  clear_has_command();
  ::Zaviruha::Packet_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Packet::set_allocated_command(::Zaviruha::Packet_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:Zaviruha.Packet.command)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Zaviruha

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ZVPacket_2eproto__INCLUDED
